var jsPsychSerialReactionTime = (function (i) {
  "use strict";
  var h = {
    name: "@jspsych/plugin-serial-reaction-time",
    version: "2.0.0",
    description: "jsPsych plugin for running a serial reaction time task",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-serial-reaction-time",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/serial-reaction-time",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const m = {
    name: "serial-reaction-time",
    version: h.version,
    parameters: {
      grid: { type: i.ParameterType.BOOL, array: !0, default: [[1, 1, 1, 1]] },
      target: { type: i.ParameterType.INT, array: !0, default: void 0 },
      choices: { type: i.ParameterType.KEYS, array: !0, default: [["3", "5", "7", "9"]] },
      grid_square_size: { type: i.ParameterType.INT, default: 100 },
      target_color: { type: i.ParameterType.STRING, default: "#999" },
      response_ends_trial: { type: i.ParameterType.BOOL, default: !0 },
      pre_target_duration: { type: i.ParameterType.INT, default: 0 },
      trial_duration: { type: i.ParameterType.INT, default: null },
      show_response_feedback: { type: i.ParameterType.BOOL, default: !1 },
      feedback_duration: { type: i.ParameterType.INT, default: 200 },
      fade_duration: { type: i.ParameterType.INT, default: null },
      prompt: { type: i.ParameterType.HTML_STRING, default: null, no_function: !1 },
    },
    data: {
      grid: { type: i.ParameterType.COMPLEX, array: !0 },
      target: { type: i.ParameterType.COMPLEX, array: !0 },
      response: { type: i.ParameterType.STRING, array: !0 },
      rt: { type: i.ParameterType.INT },
      correct: { type: i.ParameterType.BOOL },
    },
  };
  class g {
    constructor(t) {
      (this.jsPsych = t),
        (this.stimulus = function (e, r, a, s, c) {
          for (
            var l =
                "<div id='jspsych-serial-reaction-time-stimulus' style='margin:auto; display: table; table-layout: fixed; border-spacing:" +
                r / 4 +
                "px'>",
              o = 0;
            o < e.length;
            o++
          ) {
            l +=
              "<div class='jspsych-serial-reaction-time-stimulus-row' style='display:table-row;'>";
            for (var n = 0; n < e[o].length; n++)
              (l +=
                "<div class='jspsych-serial-reaction-time-stimulus-cell' id='jspsych-serial-reaction-time-stimulus-cell-" +
                o +
                "-" +
                n +
                "' style='width:" +
                r +
                "px; height:" +
                r +
                "px; display:table-cell; vertical-align:middle; text-align: center; font-size:" +
                r / 2 +
                "px;"),
                e[o][n] == 1 && (l += "border: 2px solid black;"),
                typeof a != "undefined" &&
                  a[0] == o &&
                  a[1] == n &&
                  (l += "background-color: " + s + ";"),
                (l += "'>"),
                typeof c != "undefined" && c[o][n] !== !1 && (l += c[o][n]),
                (l += "</div>");
            l += "</div>";
          }
          return (l += "</div>"), l;
        });
    }
    trial(t, e) {
      for (var r = e.choices.flat(); r.indexOf("") > -1; ) r.splice(r.indexOf(""), 1);
      var a,
        s = { rt: null, key: !1, correct: !1 };
      const c = () => {
          this.jsPsych.pluginAPI.cancelKeyboardResponse(a);
          var u = { rt: s.rt, response: s.key, correct: s.correct, grid: e.grid, target: e.target };
          this.jsPsych.finishTrial(u);
        },
        l = () => {
          if (s.rt == null || e.show_response_feedback == !1) c();
          else {
            var u = s.correct ? "#0f0" : "#f00";
            (t.querySelector(
              "#jspsych-serial-reaction-time-stimulus-cell-" +
                s.responseLoc[0] +
                "-" +
                s.responseLoc[1]
            ).style.transition = ""),
              (t.querySelector(
                "#jspsych-serial-reaction-time-stimulus-cell-" +
                  s.responseLoc[0] +
                  "-" +
                  s.responseLoc[1]
              ).style.backgroundColor = u),
              this.jsPsych.pluginAPI.setTimeout(c, e.feedback_duration);
          }
        },
        o = (u) => {
          s = s.rt == null ? u : s;
          for (var y = [], d = 0; d < e.choices.length; d++)
            for (var p = 0; p < e.choices[d].length; p++) {
              var P = e.choices[d][p];
              if (this.jsPsych.pluginAPI.compareKeys(u.key, P)) {
                y = [d, p];
                break;
              }
            }
          (s.responseLoc = y),
            (s.correct = JSON.stringify(y) == JSON.stringify(e.target)),
            e.response_ends_trial && (e.show_response_feedback ? l() : c());
        },
        n = () => {
          e.fade_duration == null ||
            (t.querySelector(
              "#jspsych-serial-reaction-time-stimulus-cell-" + e.target[0] + "-" + e.target[1]
            ).style.transition = "background-color " + e.fade_duration),
            (t.querySelector(
              "#jspsych-serial-reaction-time-stimulus-cell-" + e.target[0] + "-" + e.target[1]
            ).style.backgroundColor = e.target_color),
            (a = this.jsPsych.pluginAPI.getKeyboardResponse({
              callback_function: o,
              valid_responses: r,
              allow_held_key: !1,
            })),
            e.trial_duration !== null && this.jsPsych.pluginAPI.setTimeout(l, e.trial_duration);
        };
      var f = this.stimulus(e.grid, e.grid_square_size);
      (t.innerHTML = f),
        e.pre_target_duration <= 0
          ? n()
          : this.jsPsych.pluginAPI.setTimeout(n, e.pre_target_duration),
        e.prompt !== null && (t.innerHTML += e.prompt);
    }
    simulate(t, e, r, a) {
      e == "data-only" && (a(), this.simulate_data_only(t, r)),
        e == "visual" && this.simulate_visual(t, r, a);
    }
    create_simulation_data(t, e) {
      let r;
      if (this.jsPsych.randomization.sampleBernoulli(0.8) == 1)
        r = t.choices[t.target[0]][t.target[1]];
      else
        for (
          r = this.jsPsych.pluginAPI.getValidKey(t.choices);
          r == t.choices[t.target[0]][t.target[1]];

        )
          r = this.jsPsych.pluginAPI.getValidKey(t.choices);
      const a = {
          grid: t.grid,
          target: t.target,
          response: r,
          rt: this.jsPsych.randomization.sampleExGaussian(500, 50, 1 / 150, !0),
          correct: r == t.choices[t.target[0]][t.target[1]],
        },
        s = this.jsPsych.pluginAPI.mergeSimulationData(a, e);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(t, s), s;
    }
    simulate_data_only(t, e) {
      const r = this.create_simulation_data(t, e);
      this.jsPsych.finishTrial(r);
    }
    simulate_visual(t, e, r) {
      const a = this.create_simulation_data(t, e),
        s = this.jsPsych.getDisplayElement();
      this.trial(s, t), r(), a.rt !== null && this.jsPsych.pluginAPI.pressKey(a.response, a.rt);
    }
  }
  return (g.info = m), g;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
