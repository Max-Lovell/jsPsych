var jsPsychSketchpad = (function (a) {
  "use strict";
  var d = {
    name: "@jspsych/plugin-sketchpad",
    version: "2.0.0",
    description: "jsPsych plugin for sketching a response",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-sketchpad",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/sketchpad",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const h = {
    name: "sketchpad",
    version: d.version,
    parameters: {
      canvas_shape: { type: a.ParameterType.STRING, default: "rectangle" },
      canvas_width: { type: a.ParameterType.INT, default: 500 },
      canvas_height: { type: a.ParameterType.INT, default: 500 },
      canvas_diameter: { type: a.ParameterType.INT, default: 500 },
      canvas_border_width: { type: a.ParameterType.INT, default: 0 },
      canvas_border_color: { type: a.ParameterType.STRING, default: "#000" },
      background_image: { type: a.ParameterType.IMAGE, default: null },
      background_color: { type: a.ParameterType.STRING, default: "#ffffff" },
      stroke_width: { type: a.ParameterType.INT, default: 2 },
      stroke_color: { type: a.ParameterType.STRING, default: "#000000" },
      stroke_color_palette: { type: a.ParameterType.STRING, array: !0, default: [] },
      prompt: { type: a.ParameterType.HTML_STRING, default: null },
      prompt_location: { type: a.ParameterType.STRING, default: "abovecanvas" },
      save_final_image: { type: a.ParameterType.BOOL, default: !0 },
      save_strokes: { type: a.ParameterType.BOOL, default: !0 },
      key_to_draw: { type: a.ParameterType.KEY, default: null },
      show_finished_button: { type: a.ParameterType.BOOL, default: !0 },
      finished_button_label: { type: a.ParameterType.STRING, default: "Finished" },
      show_clear_button: { type: a.ParameterType.BOOL, default: !0 },
      clear_button_label: { type: a.ParameterType.STRING, default: "Clear" },
      show_undo_button: { type: a.ParameterType.BOOL, default: !0 },
      undo_button_label: { type: a.ParameterType.STRING, default: "Undo" },
      show_redo_button: { type: a.ParameterType.BOOL, default: !0 },
      redo_button_label: { type: a.ParameterType.STRING, default: "Redo" },
      choices: { type: a.ParameterType.KEYS, default: "NO_KEYS" },
      trial_duration: { type: a.ParameterType.INT, default: null },
      show_countdown_trial_duration: { type: a.ParameterType.BOOL, default: !1 },
      countdown_timer_html: {
        type: a.ParameterType.HTML_STRING,
        default: '<span id="sketchpad-timer"></span> remaining',
      },
    },
    data: {
      rt: { type: a.ParameterType.INT },
      response: { type: a.ParameterType.STRING },
      png: { type: a.ParameterType.STRING },
      strokes: {
        type: a.ParameterType.COMPLEX,
        array: !0,
        parameters: {
          action: { type: a.ParameterType.STRING },
          x: { type: a.ParameterType.INT, optional: !0 },
          y: { type: a.ParameterType.INT, optional: !0 },
          t: { type: a.ParameterType.INT, optional: !0 },
          color: { type: a.ParameterType.STRING, optional: !0 },
        },
      },
    },
  };
  class n {
    constructor(e) {
      (this.jsPsych = e),
        (this.is_drawing = !1),
        (this.strokes = []),
        (this.stroke = []),
        (this.undo_history = []),
        (this.mouse_position = { x: 0, y: 0 }),
        (this.draw_key_held = !1);
    }
    trial(e, t, s) {
      return (
        (this.display = e),
        (this.params = t),
        (this.current_stroke_color = t.stroke_color),
        this.init_display(),
        this.setup_event_listeners(),
        this.add_background_color(),
        this.add_background_image().then(() => {
          s();
        }),
        (this.start_time = performance.now()),
        this.set_trial_duration_timer(),
        new Promise((i, r) => {
          this.trial_finished_handler = i;
        })
      );
    }
    init_display() {
      this.add_css();
      let e;
      if (this.params.canvas_shape == "rectangle")
        e = `
        <canvas id="sketchpad-canvas" 
        width="${this.params.canvas_width}" 
        height="${this.params.canvas_height}" 
        class="sketchpad-rectangle"></canvas>
      `;
      else if (this.params.canvas_shape == "circle")
        e = `
        <canvas id="sketchpad-canvas" 
        width="${this.params.canvas_diameter}" 
        height="${this.params.canvas_diameter}" 
        class="sketchpad-circle">
        </canvas>
      `;
      else
        throw new Error(
          '`canvas_shape` parameter in sketchpad plugin must be either "rectangle" or "circle"'
        );
      let t = '<div id="sketchpad-controls">';
      t += '<div id="sketchpad-color-palette">';
      for (const o of this.params.stroke_color_palette)
        t += `<button class="sketchpad-color-select" data-color="${o}" style="background-color:${o};"></button>`;
      (t += "</div>"),
        (t += '<div id="sketchpad-actions">'),
        this.params.show_clear_button &&
          (t += `<button class="jspsych-btn" id="sketchpad-clear" disabled>${this.params.clear_button_label}</button>`),
        this.params.show_undo_button &&
          ((t += `<button class="jspsych-btn" id="sketchpad-undo" disabled>${this.params.undo_button_label}</button>`),
          this.params.show_redo_button &&
            (t += `<button class="jspsych-btn" id="sketchpad-redo" disabled>${this.params.redo_button_label}</button>`)),
        (t += "</div></div>"),
        (e += t);
      let s = "";
      this.params.show_finished_button &&
        (s = `<p id="finish-btn"><button class="jspsych-btn" id="sketchpad-end">${this.params.finished_button_label}</button></p>`);
      let i = "";
      this.params.show_countdown_trial_duration &&
        this.params.trial_duration &&
        (i = `<p id="countdown-timer">${this.params.countdown_timer_html}</p>`);
      let r;
      this.params.prompt !== null
        ? (this.params.prompt_location == "abovecanvas" && (r = this.params.prompt + i + e + s),
          this.params.prompt_location == "belowcanvas" && (r = i + e + this.params.prompt + s),
          this.params.prompt_location == "belowbutton" && (r = i + e + s + this.params.prompt))
        : (r = i + e + s),
        (this.display.innerHTML = r),
        (this.sketchpad = this.display.querySelector("#sketchpad-canvas")),
        (this.ctx = this.sketchpad.getContext("2d"));
    }
    setup_event_listeners() {
      document.addEventListener("pointermove", (t) => {
        this.mouse_position = { x: t.clientX, y: t.clientY };
      }),
        this.params.show_finished_button &&
          this.display.querySelector("#sketchpad-end").addEventListener("click", () => {
            this.end_trial("button");
          }),
        this.sketchpad.addEventListener("pointerdown", this.start_draw),
        this.sketchpad.addEventListener("pointermove", this.move_draw),
        this.sketchpad.addEventListener("pointerup", this.end_draw),
        this.sketchpad.addEventListener("pointerleave", this.end_draw),
        this.sketchpad.addEventListener("pointercancel", this.end_draw),
        this.params.key_to_draw !== null &&
          (document.addEventListener("keydown", (t) => {
            t.key == this.params.key_to_draw &&
              !this.is_drawing &&
              !this.draw_key_held &&
              ((this.draw_key_held = !0),
              document.elementFromPoint(this.mouse_position.x, this.mouse_position.y) ==
                this.sketchpad &&
                this.sketchpad.dispatchEvent(
                  new PointerEvent("pointerdown", {
                    clientX: this.mouse_position.x,
                    clientY: this.mouse_position.y,
                  })
                ));
          }),
          document.addEventListener("keyup", (t) => {
            t.key == this.params.key_to_draw &&
              ((this.draw_key_held = !1),
              document.elementFromPoint(this.mouse_position.x, this.mouse_position.y) ==
                this.sketchpad &&
                this.sketchpad.dispatchEvent(
                  new PointerEvent("pointerup", {
                    clientX: this.mouse_position.x,
                    clientY: this.mouse_position.y,
                  })
                ));
          })),
        this.params.show_undo_button &&
          (this.display.querySelector("#sketchpad-undo").addEventListener("click", this.undo),
          this.params.show_redo_button &&
            this.display.querySelector("#sketchpad-redo").addEventListener("click", this.redo)),
        this.params.show_clear_button &&
          this.display.querySelector("#sketchpad-clear").addEventListener("click", this.clear);
      const e = Array.from(this.display.querySelectorAll(".sketchpad-color-select"));
      for (const t of e)
        t.addEventListener("click", (s) => {
          const i = s.target;
          this.current_stroke_color = i.getAttribute("data-color");
        });
      this.jsPsych.pluginAPI.getKeyboardResponse({
        callback_function: this.after_key_response,
        valid_responses: this.params.choices,
        persist: !1,
        allow_held_key: !1,
      });
    }
    add_css() {
      document.querySelector("head").insertAdjacentHTML(
        "beforeend",
        `<style id="sketchpad-styles">
        #sketchpad-controls {
          line-height: 1; 
          width:${
            this.params.canvas_shape == "rectangle"
              ? this.params.canvas_width + this.params.canvas_border_width * 2
              : this.params.canvas_diameter + this.params.canvas_border_width * 2
          }px; 
          display: flex; 
          justify-content: space-between; 
          flex-wrap: wrap;
          margin: auto;
        }
        #sketchpad-color-palette { 
          display: inline-block; text-align:left; flex-grow: 1;
        }
        .sketchpad-color-select { 
          cursor: pointer; height: 33px; width: 33px; border-radius: 4px; padding: 0; border: 1px solid #ccc; 
        }
        #sketchpad-actions {
          display:inline-block; text-align:right; flex-grow: 1;
        }
        #sketchpad-actions button {
          margin-left: 4px;
        }
        #sketchpad-canvas {
          touch-action: none;
          border: ${this.params.canvas_border_width}px solid ${this.params.canvas_border_color};
        }
        .sketchpad-circle {
          border-radius: ${this.params.canvas_diameter / 2}px;
        }
        #countdown-timer {
          width:${
            this.params.canvas_shape == "rectangle"
              ? this.params.canvas_width + this.params.canvas_border_width * 2
              : this.params.canvas_diameter + this.params.canvas_border_width * 2
          }px; 
          text-align: right;
          font-size: 12px; 
          margin-bottom: 0.2em;
        }
      </style>`
      );
    }
    add_background_color() {
      (this.ctx.fillStyle = this.params.background_color),
        this.params.canvas_shape == "rectangle" &&
          this.ctx.fillRect(0, 0, this.params.canvas_width, this.params.canvas_height),
        this.params.canvas_shape == "circle" &&
          this.ctx.fillRect(0, 0, this.params.canvas_diameter, this.params.canvas_diameter);
    }
    add_background_image() {
      return new Promise((e, t) => {
        this.params.background_image !== null
          ? ((this.background_image = new Image()),
            (this.background_image.src = this.params.background_image),
            (this.background_image.onload = () => {
              this.ctx.drawImage(this.background_image, 0, 0), e(!0);
            }))
          : e(!1);
      });
    }
    start_draw(e) {
      this.is_drawing = !0;
      const t = Math.round(e.clientX - this.sketchpad.getBoundingClientRect().left),
        s = Math.round(e.clientY - this.sketchpad.getBoundingClientRect().top);
      (this.undo_history = []),
        this.set_redo_btn_state(!1),
        this.ctx.beginPath(),
        this.ctx.moveTo(t, s),
        (this.ctx.strokeStyle = this.current_stroke_color),
        (this.ctx.lineJoin = "round"),
        (this.ctx.lineWidth = this.params.stroke_width),
        (this.stroke = []),
        this.stroke.push({
          x: t,
          y: s,
          color: this.current_stroke_color,
          action: "start",
          t: Math.round(performance.now() - this.start_time),
        }),
        this.sketchpad.releasePointerCapture(e.pointerId);
    }
    move_draw(e) {
      if (this.is_drawing) {
        const t = Math.round(e.clientX - this.sketchpad.getBoundingClientRect().left),
          s = Math.round(e.clientY - this.sketchpad.getBoundingClientRect().top);
        this.ctx.lineTo(t, s), this.ctx.stroke(), this.stroke.push({ x: t, y: s, action: "move" });
      }
    }
    end_draw(e) {
      this.is_drawing &&
        (this.stroke.push({ action: "end", t: Math.round(performance.now() - this.start_time) }),
        this.strokes.push(this.stroke),
        this.set_undo_btn_state(!0),
        this.set_clear_btn_state(!0)),
        (this.is_drawing = !1);
    }
    render_drawing() {
      this.ctx.clearRect(0, 0, this.sketchpad.width, this.sketchpad.height),
        this.add_background_color(),
        this.background_image && this.ctx.drawImage(this.background_image, 0, 0);
      for (const e of this.strokes)
        for (const t of e)
          t.action == "start" &&
            (this.ctx.beginPath(),
            this.ctx.moveTo(t.x, t.y),
            (this.ctx.strokeStyle = t.color),
            (this.ctx.lineJoin = "round"),
            (this.ctx.lineWidth = this.params.stroke_width)),
            t.action == "move" && (this.ctx.lineTo(t.x, t.y), this.ctx.stroke());
    }
    undo() {
      this.undo_history.push(this.strokes.pop()),
        this.set_redo_btn_state(!0),
        this.strokes.length == 0 && this.set_undo_btn_state(!1),
        this.render_drawing();
    }
    redo() {
      this.strokes.push(this.undo_history.pop()),
        this.set_undo_btn_state(!0),
        this.undo_history.length == 0 && this.set_redo_btn_state(!1),
        this.render_drawing();
    }
    clear() {
      (this.strokes = []),
        (this.undo_history = []),
        this.render_drawing(),
        this.set_redo_btn_state(!1),
        this.set_undo_btn_state(!1),
        this.set_clear_btn_state(!1);
    }
    set_undo_btn_state(e) {
      this.params.show_undo_button && (this.display.querySelector("#sketchpad-undo").disabled = !e);
    }
    set_redo_btn_state(e) {
      this.params.show_undo_button &&
        this.params.show_redo_button &&
        (this.display.querySelector("#sketchpad-redo").disabled = !e);
    }
    set_clear_btn_state(e) {
      this.params.show_clear_button &&
        (this.display.querySelector("#sketchpad-clear").disabled = !e);
    }
    set_trial_duration_timer() {
      this.params.trial_duration !== null &&
        (this.jsPsych.pluginAPI.setTimeout(() => {
          this.end_trial();
        }, this.params.trial_duration),
        this.params.show_countdown_trial_duration &&
          (this.timer_interval = setInterval(() => {
            const e = this.params.trial_duration - (performance.now() - this.start_time);
            let t = Math.floor(e / 1e3 / 60),
              s = Math.ceil((e - t * 1e3 * 60) / 1e3);
            s == 60 && ((s = 0), t++);
            const i = t.toString(),
              r = s.toString().padStart(2, "0"),
              o = this.display.querySelector("#sketchpad-timer");
            o && (o.innerHTML = `${i}:${r}`),
              e <= 0 && (o && (o.innerHTML = "0:00"), clearInterval(this.timer_interval));
          }, 250)));
    }
    after_key_response(e) {
      this.end_trial(e.key);
    }
    end_trial(e = null) {
      this.jsPsych.pluginAPI.cancelAllKeyboardResponses(), clearInterval(this.timer_interval);
      const t = {};
      (t.rt = Math.round(performance.now() - this.start_time)),
        (t.response = e),
        this.params.save_final_image && (t.png = this.sketchpad.toDataURL()),
        this.params.save_strokes && (t.strokes = this.strokes),
        document.querySelector("#sketchpad-styles").remove(),
        this.jsPsych.finishTrial(t),
        this.trial_finished_handler();
    }
  }
  return (n.info = h), n;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
