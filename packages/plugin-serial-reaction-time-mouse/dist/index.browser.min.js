var jsPsychSerialReactionTimeMouse = (function (s) {
  "use strict";
  var g = {
    name: "@jspsych/plugin-serial-reaction-time-mouse",
    version: "2.0.0",
    description: "jsPsych plugin for running a serial reaction time task",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-serial-reaction-time-mouse",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/serial-reaction-time-mouse",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const y = {
    name: "serial-reaction-time-mouse",
    version: g.version,
    parameters: {
      grid: { type: s.ParameterType.BOOL, array: !0, default: [[1, 1, 1, 1]] },
      target: { type: s.ParameterType.INT, array: !0, default: void 0 },
      grid_square_size: { type: s.ParameterType.INT, default: 100 },
      target_color: { type: s.ParameterType.STRING, default: "#999" },
      response_ends_trial: { type: s.ParameterType.BOOL, default: !0 },
      pre_target_duration: { type: s.ParameterType.INT, default: 0 },
      trial_duration: { type: s.ParameterType.INT, default: null },
      fade_duration: { type: s.ParameterType.INT, default: null },
      allow_nontarget_responses: { type: s.ParameterType.BOOL, default: !1 },
      prompt: { type: s.ParameterType.HTML_STRING, default: null, no_function: !1 },
    },
    data: {
      grid: { type: s.ParameterType.COMPLEX, array: !0 },
      target: { type: s.ParameterType.COMPLEX, array: !0 },
      response: { type: s.ParameterType.INT, array: !0 },
      rt: { type: s.ParameterType.INT },
      correct: { type: s.ParameterType.BOOL },
    },
  };
  class p {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, t) {
      var r = -1,
        a = { rt: null, row: null, column: null };
      const n = () => {
        var u;
        t.allow_nontarget_responses
          ? (u = e.querySelectorAll(".jspsych-serial-reaction-time-stimulus-cell"))
          : (u = [
              e.querySelector(
                "#jspsych-serial-reaction-time-stimulus-cell-" + t.target[0] + "-" + t.target[1]
              ),
            ]);
        for (var d = 0; d < u.length; d++)
          u[d].addEventListener("mousedown", (m) => {
            if (r != -1) {
              var c = {};
              (c.row = m.currentTarget.getAttribute("data-row")),
                (c.column = m.currentTarget.getAttribute("data-column")),
                (c.rt = Math.round(performance.now() - r)),
                o(c);
            }
          });
        (r = performance.now()),
          t.fade_duration == null ||
            (e.querySelector(
              "#jspsych-serial-reaction-time-stimulus-cell-" + t.target[0] + "-" + t.target[1]
            ).style.transition = "background-color " + t.fade_duration),
          (e.querySelector(
            "#jspsych-serial-reaction-time-stimulus-cell-" + t.target[0] + "-" + t.target[1]
          ).style.backgroundColor = t.target_color),
          t.trial_duration !== null && this.jsPsych.pluginAPI.setTimeout(l, t.trial_duration);
      };
      var i = this.stimulus(t.grid, t.grid_square_size);
      (e.innerHTML = i),
        t.pre_target_duration <= 0
          ? n()
          : this.jsPsych.pluginAPI.setTimeout(n, t.pre_target_duration),
        t.prompt !== null && e.insertAdjacentHTML("beforeend", t.prompt);
      const l = () => {
        var u = {
          rt: a.rt,
          grid: t.grid,
          target: t.target,
          response: [parseInt(a.row, 10), parseInt(a.column, 10)],
          correct: a.row == t.target[0] && a.column == t.target[1],
        };
        this.jsPsych.finishTrial(u);
      };
      function o(u) {
        (a = a.rt == null ? u : a), t.response_ends_trial && l();
      }
    }
    stimulus(e, t, r, a, n) {
      for (
        var i =
            "<div id='jspsych-serial-reaction-time-stimulus' style='margin:auto; display: table; table-layout: fixed; border-spacing:" +
            t / 4 +
            "px'>",
          l = 0;
        l < e.length;
        l++
      ) {
        i += "<div class='jspsych-serial-reaction-time-stimulus-row' style='display:table-row;'>";
        for (var o = 0; o < e[l].length; o++) {
          var u = "jspsych-serial-reaction-time-stimulus-cell";
          (i +=
            "<div class='" +
            u +
            "' id='jspsych-serial-reaction-time-stimulus-cell-" +
            l +
            "-" +
            o +
            "' data-row=" +
            l +
            " data-column=" +
            o +
            " style='width:" +
            t +
            "px; height:" +
            t +
            "px; display:table-cell; vertical-align:middle; text-align: center; cursor: pointer; font-size:" +
            t / 2 +
            "px;"),
            e[l][o] == 1 && (i += "border: 2px solid black;"),
            typeof r != "undefined" &&
              r[0] == l &&
              r[1] == o &&
              (i += "background-color: " + a + ";"),
            (i += "'>"),
            typeof n != "undefined" && n[l][o] !== !1 && (i += n[l][o]),
            (i += "</div>");
        }
        i += "</div>";
      }
      return (i += "</div>"), i;
    }
    simulate(e, t, r, a) {
      t == "data-only" && (a(), this.simulate_data_only(e, r)),
        t == "visual" && this.simulate_visual(e, r, a);
    }
    create_simulation_data(e, t) {
      let r = this.jsPsych.utils.deepCopy(e.target);
      if (e.allow_nontarget_responses && this.jsPsych.randomization.sampleBernoulli(0.8) !== 1)
        for (; r[0] == e.target[0] && r[1] == e.target[1]; )
          r[0] == this.jsPsych.randomization.randomInt(0, e.grid.length),
            r[1] == this.jsPsych.randomization.randomInt(0, e.grid[r[0]].length);
      const a = {
          grid: e.grid,
          target: e.target,
          response: r,
          rt:
            e.pre_target_duration +
            this.jsPsych.randomization.sampleExGaussian(500, 50, 1 / 150, !0),
          correct: r[0] == e.target[0] && r[1] == e.target[1],
        },
        n = this.jsPsych.pluginAPI.mergeSimulationData(a, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, n), n;
    }
    simulate_data_only(e, t) {
      const r = this.create_simulation_data(e, t);
      this.jsPsych.finishTrial(r);
    }
    simulate_visual(e, t, r) {
      const a = this.create_simulation_data(e, t),
        n = this.jsPsych.getDisplayElement();
      if ((this.trial(n, e), r(), a.rt !== null)) {
        const i = n.querySelector(
          `.jspsych-serial-reaction-time-stimulus-cell[data-row="${a.response[0]}"][data-column="${a.response[1]}"]`
        );
        this.jsPsych.pluginAPI.clickTarget(i, a.rt);
      }
    }
  }
  return (p.info = y), p;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
