var jsPsychReconstruction = (function (a) {
  "use strict";
  var h = {
    name: "@jspsych/plugin-reconstruction",
    version: "2.0.0",
    description:
      "a jspsych plugin for a reconstruction task where the participant recreates a stimulus from memory",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest  --passWithNoTests",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-reconstruction",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/reconstruction",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const d = {
    name: "reconstruction",
    version: h.version,
    parameters: {
      stim_function: { type: a.ParameterType.FUNCTION, default: void 0 },
      starting_value: { type: a.ParameterType.FLOAT, default: 0.5 },
      step_size: { type: a.ParameterType.FLOAT, default: 0.05 },
      key_increase: { type: a.ParameterType.KEY, default: "h" },
      key_decrease: { type: a.ParameterType.KEY, default: "g" },
      button_label: { type: a.ParameterType.STRING, default: "Continue" },
    },
    data: {
      start_value: { type: a.ParameterType.INT },
      final_value: { type: a.ParameterType.INT },
      rt: { type: a.ParameterType.INT },
    },
  };
  class y {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, s) {
      var t = s.starting_value;
      const i = () => {
          var n = performance.now(),
            l = Math.round(n - u);
          this.jsPsych.pluginAPI.cancelKeyboardResponse(o);
          var p = { rt: l, final_value: t, start_value: s.starting_value };
          this.jsPsych.finishTrial(p);
        },
        c = (n) => {
          (e.innerHTML =
            '<div id="jspsych-reconstruction-stim-container">' + s.stim_function(n) + "</div>"),
            (e.innerHTML +=
              '<button id="jspsych-reconstruction-next" class="jspsych-btn jspsych-reconstruction">' +
              s.button_label +
              "</button>"),
            e.querySelector("#jspsych-reconstruction-next").addEventListener("click", i);
        },
        r = (n) => {
          var l = s.key_increase,
            p = s.key_decrease;
          this.jsPsych.pluginAPI.compareKeys(n.key, l)
            ? (t = t + s.step_size)
            : this.jsPsych.pluginAPI.compareKeys(n.key, p) && (t = t - s.step_size),
            (t = Math.max(Math.min(1, t), 0)),
            c(t);
        };
      var o = this.jsPsych.pluginAPI.getKeyboardResponse({
        callback_function: r,
        valid_responses: [s.key_increase, s.key_decrease],
        rt_method: "performance",
        persist: !0,
        allow_held_key: !0,
      });
      c(t);
      var u = performance.now();
    }
    simulate(e, s, t, i) {
      s == "data-only" && (i(), this.simulate_data_only(e, t)),
        s == "visual" && this.simulate_visual(e, t, i);
    }
    create_simulation_data(e, s) {
      const t = {
          rt: this.jsPsych.randomization.sampleExGaussian(2e3, 200, 0.005, !0),
          start_value: e.starting_value,
          final_value:
            this.jsPsych.randomization.randomInt(0, Math.round(1 / e.step_size)) * e.step_size,
        },
        i = this.jsPsych.pluginAPI.mergeSimulationData(t, s);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, i), i;
    }
    simulate_data_only(e, s) {
      const t = this.create_simulation_data(e, s);
      this.jsPsych.finishTrial(t);
    }
    simulate_visual(e, s, t) {
      const i = this.create_simulation_data(e, s),
        c = this.jsPsych.getDisplayElement();
      this.trial(c, e), t();
      let r = Math.round((i.final_value - e.starting_value) / e.step_size);
      const o = (i.rt - 300) / r;
      let u = 0;
      for (; r != 0; )
        r > 0
          ? (this.jsPsych.pluginAPI.pressKey(e.key_increase, u + o), r--)
          : (this.jsPsych.pluginAPI.pressKey(e.key_decrease, u + o), r++),
          (u += o);
      this.jsPsych.pluginAPI.clickTarget(c.querySelector("#jspsych-reconstruction-next"), i.rt);
    }
  }
  return (y.info = d), y;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
