var jsPsychAnimation = (function (s) {
  "use strict";
  var y = {
    name: "@jspsych/plugin-animation",
    version: "2.0.0",
    description: "jsPsych plugin for showing animations and recording keyboard responses",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-animation",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/animation",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const d = {
    name: "animation",
    version: y.version,
    parameters: {
      stimuli: { type: s.ParameterType.IMAGE, default: void 0, array: !0 },
      frame_time: { type: s.ParameterType.INT, default: 250 },
      frame_isi: { type: s.ParameterType.INT, default: 0 },
      sequence_reps: { type: s.ParameterType.INT, default: 1 },
      choices: { type: s.ParameterType.KEYS, default: "ALL_KEYS" },
      prompt: { type: s.ParameterType.HTML_STRING, default: null },
      render_on_canvas: { type: s.ParameterType.BOOL, default: !0 },
    },
    data: {
      animation_sequence: {
        type: s.ParameterType.COMPLEX,
        array: !0,
        parameters: {
          stimulus: { type: s.ParameterType.STRING },
          time: { type: s.ParameterType.INT },
        },
      },
      response: {
        type: s.ParameterType.COMPLEX,
        array: !0,
        parameters: {
          stimulus: { type: s.ParameterType.STRING },
          rt: { type: s.ParameterType.INT },
          key_press: { type: s.ParameterType.STRING },
        },
      },
    },
  };
  class c {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, t) {
      var a = t.frame_time + t.frame_isi,
        i = 0,
        r = 0,
        o = performance.now(),
        p = [],
        u = [],
        l = "";
      if (t.render_on_canvas) {
        if (e.hasChildNodes()) for (; e.firstChild; ) e.removeChild(e.firstChild);
        var m = document.createElement("canvas");
        (m.id = "jspsych-animation-image"),
          (m.style.margin = "0"),
          (m.style.padding = "0"),
          e.insertBefore(m, null);
        var _ = m.getContext("2d");
      }
      const g = () => {
        this.jsPsych.pluginAPI.cancelKeyboardResponse(T);
        var n = { animation_sequence: p, response: u };
        this.jsPsych.finishTrial(n);
      };
      var f = setInterval(() => {
        var n = !0;
        t.render_on_canvas || (e.innerHTML = ""),
          i++,
          i == t.stimuli.length &&
            ((i = 0), r++, r >= t.sequence_reps && (g(), clearInterval(f), (n = !1))),
          n && h();
      }, a);
      const h = () => {
        if (t.render_on_canvas) {
          e.querySelector("#jspsych-animation-image").style.visibility = "visible";
          var n = new Image();
          (n.src = t.stimuli[i]),
            (m.height = n.naturalHeight),
            (m.width = n.naturalWidth),
            _.drawImage(n, 0, 0),
            t.prompt !== null && i == 0 && r == 0 && e.insertAdjacentHTML("beforeend", t.prompt);
        } else
          (e.innerHTML = '<img src="' + t.stimuli[i] + '" id="jspsych-animation-image"></img>'),
            t.prompt !== null && (e.innerHTML += t.prompt);
        (l = t.stimuli[i]),
          p.push({ stimulus: t.stimuli[i], time: Math.round(performance.now() - o) }),
          t.frame_isi > 0 &&
            this.jsPsych.pluginAPI.setTimeout(() => {
              (e.querySelector("#jspsych-animation-image").style.visibility = "hidden"),
                (l = "blank"),
                p.push({ stimulus: "blank", time: Math.round(performance.now() - o) });
            }, t.frame_time);
      };
      var P = (n) => {
          u.push({ key_press: n.key, rt: n.rt, stimulus: l }),
            (e.querySelector("#jspsych-animation-image").className += " responded");
        },
        T = this.jsPsych.pluginAPI.getKeyboardResponse({
          callback_function: P,
          valid_responses: t.choices,
          rt_method: "performance",
          persist: !0,
          allow_held_key: !1,
        });
      h();
    }
    simulate(e, t, a, i) {
      t == "data-only" && (i(), this.simulate_data_only(e, a)),
        t == "visual" && this.simulate_visual(e, a, i);
    }
    create_simulation_data(e, t) {
      const a = [],
        i = [];
      let r = 0;
      const o = () => this.jsPsych.randomization.sampleWithReplacement([!0, !1], 1, [1, 10])[0];
      for (let l = 0; l < e.sequence_reps; l++)
        for (const m of e.stimuli)
          a.push({ stimulus: m, time: r }),
            o() &&
              i.push({
                key_press: this.jsPsych.pluginAPI.getValidKey(e.choices),
                rt: r + this.jsPsych.randomization.randomInt(0, e.frame_time - 1),
                current_stim: m,
              }),
            (r += e.frame_time),
            e.frame_isi > 0 &&
              (a.push({ stimulus: "blank", time: r }),
              o() &&
                i.push({
                  key_press: this.jsPsych.pluginAPI.getValidKey(e.choices),
                  rt: r + this.jsPsych.randomization.randomInt(0, e.frame_isi - 1),
                  current_stim: "blank",
                }),
              (r += e.frame_isi));
      const p = { animation_sequence: a, response: i },
        u = this.jsPsych.pluginAPI.mergeSimulationData(p, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, u), u;
    }
    simulate_data_only(e, t) {
      const a = this.create_simulation_data(e, t);
      this.jsPsych.finishTrial(a);
    }
    simulate_visual(e, t, a) {
      const i = this.create_simulation_data(e, t),
        r = this.jsPsych.getDisplayElement();
      this.trial(r, e), a();
      for (const o of i.response) this.jsPsych.pluginAPI.pressKey(o.key_press, o.rt);
    }
  }
  return (c.info = d), c;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
