var jsPsychSameDifferentHtml = (function (a) {
  "use strict";
  var d = {
    name: "@jspsych/plugin-same-different-html",
    version: "2.0.0",
    description:
      "jsPsych plugin for showing two stimuli sequentially and getting a same / different judgment",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-same-different-html",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/same-different-html",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const y = {
    name: "same-different-html",
    version: d.version,
    parameters: {
      stimuli: { type: a.ParameterType.HTML_STRING, default: void 0, array: !0 },
      answer: { type: a.ParameterType.SELECT, options: ["same", "different"], default: void 0 },
      same_key: { type: a.ParameterType.KEY, default: "q" },
      different_key: { type: a.ParameterType.KEY, default: "p" },
      first_stim_duration: { type: a.ParameterType.INT, default: 1e3 },
      gap_duration: { type: a.ParameterType.INT, default: 500 },
      second_stim_duration: {
        type: a.ParameterType.INT,
        pretty_name: "Second stimulus duration",
        default: 1e3,
      },
      prompt: { type: a.ParameterType.HTML_STRING, default: null },
    },
    data: {
      stimulus: { type: a.ParameterType.HTML_STRING, array: !0 },
      response: { type: a.ParameterType.STRING },
      rt: { type: a.ParameterType.INT },
      correct: { type: a.ParameterType.BOOL },
      answer: { type: a.ParameterType.STRING },
    },
  };
  class p {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, t) {
      e.innerHTML = '<div class="jspsych-same-different-stimulus">' + t.stimuli[0] + "</div>";
      var s;
      if (t.first_stim_duration > 0)
        this.jsPsych.pluginAPI.setTimeout(() => {
          i();
        }, t.first_stim_duration);
      else {
        const n = (u) => {
          (s = u), i();
        };
        this.jsPsych.pluginAPI.getKeyboardResponse({
          callback_function: n,
          valid_responses: "ALL_KEYS",
          rt_method: "performance",
          persist: !1,
          allow_held_key: !1,
        });
      }
      const i = () => {
          (e.innerHTML = ""), this.jsPsych.pluginAPI.setTimeout(r, t.gap_duration);
        },
        r = () => {
          var n = '<div class="jspsych-same-different-stimulus">' + t.stimuli[1] + "</div>";
          t.prompt !== null && (n += t.prompt),
            (e.innerHTML = n),
            t.second_stim_duration > 0 &&
              this.jsPsych.pluginAPI.setTimeout(() => {
                e.querySelector(".jspsych-same-different-stimulus").style.visibility = "hidden";
              }, t.second_stim_duration);
          const u = (l) => {
            var m = !1,
              c = t.same_key,
              h = t.different_key;
            this.jsPsych.pluginAPI.compareKeys(l.key, c) && t.answer == "same" && (m = !0),
              this.jsPsych.pluginAPI.compareKeys(l.key, h) && t.answer == "different" && (m = !0);
            var o = {
              rt: l.rt,
              answer: t.answer,
              correct: m,
              stimulus: [t.stimuli[0], t.stimuli[1]],
              response: l.key,
            };
            s && ((o.rt_stim1 = s.rt), (o.response_stim1 = s.key)), this.jsPsych.finishTrial(o);
          };
          this.jsPsych.pluginAPI.getKeyboardResponse({
            callback_function: u,
            valid_responses: [t.same_key, t.different_key],
            rt_method: "performance",
            persist: !1,
            allow_held_key: !1,
          });
        };
    }
    simulate(e, t, s, i) {
      t == "data-only" && (i(), this.simulate_data_only(e, s)),
        t == "visual" && this.simulate_visual(e, s, i);
    }
    create_simulation_data(e, t) {
      const s = this.jsPsych.pluginAPI.getValidKey([e.same_key, e.different_key]),
        i = {
          stimuli: e.stimuli,
          response: s,
          answer: e.answer,
          correct: e.answer == "same" ? s == e.same_key : s == e.different_key,
          rt: this.jsPsych.randomization.sampleExGaussian(500, 50, 1 / 150, !0),
        };
      e.first_stim_duration == null &&
        ((i.rt_stim1 = this.jsPsych.randomization.sampleExGaussian(
          500,
          50,
          0.006666666666666667,
          !0
        )),
        (i.response_stim1 = this.jsPsych.pluginAPI.getValidKey([e.same_key, e.different_key])));
      const r = this.jsPsych.pluginAPI.mergeSimulationData(i, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, r), r;
    }
    simulate_data_only(e, t) {
      const s = this.create_simulation_data(e, t);
      this.jsPsych.finishTrial(s);
    }
    simulate_visual(e, t, s) {
      const i = this.create_simulation_data(e, t),
        r = this.jsPsych.getDisplayElement();
      this.trial(r, e),
        s(),
        e.first_stim_duration == null &&
          this.jsPsych.pluginAPI.pressKey(i.response_stim1, i.rt_stim1),
        this.jsPsych.pluginAPI.pressKey(i.response, e.first_stim_duration + e.gap_duration + i.rt);
    }
  }
  return (p.info = y), p;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
