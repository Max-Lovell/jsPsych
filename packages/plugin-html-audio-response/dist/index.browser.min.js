var jsPsychHtmlAudioResponse = (function (r) {
  "use strict";
  var o = {
    name: "@jspsych/plugin-html-audio-response",
    version: "2.0.0",
    description:
      "jsPsych plugin for displaying a stimulus and recording an audio response through the microphone",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest --passWithNoTests",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-html-audio-response",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/html-audio-response",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: {
      "@jspsych/config": "^3.0.0",
      "@jspsych/test-utils": "^1.2.0",
      "@types/resize-observer-browser": "^0.1.6",
    },
  };
  const d = {
    name: "html-audio-response",
    version: o.version,
    parameters: {
      stimulus: { type: r.ParameterType.HTML_STRING, default: void 0 },
      stimulus_duration: { type: r.ParameterType.INT, default: null },
      recording_duration: { type: r.ParameterType.INT, default: 2e3 },
      show_done_button: { type: r.ParameterType.BOOL, default: !0 },
      done_button_label: { type: r.ParameterType.STRING, default: "Continue" },
      record_again_button_label: { type: r.ParameterType.STRING, default: "Record again" },
      accept_button_label: { type: r.ParameterType.STRING, default: "Continue" },
      allow_playback: { type: r.ParameterType.BOOL, default: !1 },
      save_audio_url: { type: r.ParameterType.BOOL, default: !1 },
    },
    data: {
      rt: { type: r.ParameterType.INT },
      response: { type: r.ParameterType.STRING },
      stimulus: { type: r.ParameterType.HTML_STRING },
      estimated_stimulus_onset: { type: r.ParameterType.INT },
      audio_url: { type: r.ParameterType.STRING },
    },
  };
  class n {
    constructor(t) {
      (this.jsPsych = t), (this.rt = null), (this.recorded_data_chunks = []);
    }
    trial(t, e) {
      (this.recorder = this.jsPsych.pluginAPI.getMicrophoneRecorder()),
        this.setupRecordingEvents(t, e),
        this.startRecording();
    }
    showDisplay(t, e) {
      new ResizeObserver((i, a) => {
        (this.stimulus_start_time = performance.now()), a.unobserve(t);
      }).observe(t);
      let s = `<div id="jspsych-html-audio-response-stimulus">${e.stimulus}</div>`;
      e.show_done_button &&
        (s += `<p><button class="jspsych-btn" id="finish-trial">${e.done_button_label}</button></p>`),
        (t.innerHTML = s);
    }
    hideStimulus(t) {
      const e = t.querySelector("#jspsych-html-audio-response-stimulus");
      e && (e.style.visibility = "hidden");
    }
    addButtonEvent(t, e) {
      const s = t.querySelector("#finish-trial");
      s &&
        s.addEventListener("click", () => {
          const i = performance.now();
          (this.rt = Math.round(i - this.stimulus_start_time)),
            this.stopRecording().then(() => {
              e.allow_playback ? this.showPlaybackControls(t, e) : this.endTrial(t, e);
            });
        });
    }
    setupRecordingEvents(t, e) {
      (this.data_available_handler = (s) => {
        s.data.size > 0 && this.recorded_data_chunks.push(s.data);
      }),
        (this.stop_event_handler = () => {
          const s = new Blob(this.recorded_data_chunks, { type: "audio/webm" });
          this.audio_url = URL.createObjectURL(s);
          const i = new FileReader();
          i.addEventListener("load", () => {
            const a = i.result.split(",")[1];
            (this.response = a), this.load_resolver();
          }),
            i.readAsDataURL(s);
        }),
        (this.start_event_handler = (s) => {
          (this.recorded_data_chunks.length = 0),
            (this.recorder_start_time = s.timeStamp),
            this.showDisplay(t, e),
            this.addButtonEvent(t, e),
            e.stimulus_duration !== null &&
              this.jsPsych.pluginAPI.setTimeout(() => {
                this.hideStimulus(t);
              }, e.stimulus_duration),
            e.recording_duration !== null &&
              this.jsPsych.pluginAPI.setTimeout(() => {
                this.recorder.state !== "inactive" &&
                  this.stopRecording().then(() => {
                    e.allow_playback ? this.showPlaybackControls(t, e) : this.endTrial(t, e);
                  });
              }, e.recording_duration);
        }),
        this.recorder.addEventListener("dataavailable", this.data_available_handler),
        this.recorder.addEventListener("stop", this.stop_event_handler),
        this.recorder.addEventListener("start", this.start_event_handler);
    }
    startRecording() {
      this.recorder.start();
    }
    stopRecording() {
      return (
        this.recorder.stop(),
        new Promise((t) => {
          this.load_resolver = t;
        })
      );
    }
    showPlaybackControls(t, e) {
      (t.innerHTML = `
      <p><audio id="playback" src="${this.audio_url}" controls></audio></p>
      <button id="record-again" class="jspsych-btn">${e.record_again_button_label}</button>
      <button id="continue" class="jspsych-btn">${e.accept_button_label}</button>
    `),
        t.querySelector("#record-again").addEventListener("click", () => {
          URL.revokeObjectURL(this.audio_url), this.startRecording();
        }),
        t.querySelector("#continue").addEventListener("click", () => {
          this.endTrial(t, e);
        });
    }
    endTrial(t, e) {
      this.recorder.removeEventListener("dataavailable", this.data_available_handler),
        this.recorder.removeEventListener("start", this.start_event_handler),
        this.recorder.removeEventListener("stop", this.stop_event_handler);
      var s = {
        rt: this.rt,
        stimulus: e.stimulus,
        response: this.response,
        estimated_stimulus_onset: Math.round(this.stimulus_start_time - this.recorder_start_time),
      };
      e.save_audio_url ? (s.audio_url = this.audio_url) : URL.revokeObjectURL(this.audio_url),
        this.jsPsych.finishTrial(s);
    }
  }
  return (n.info = d), n;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
