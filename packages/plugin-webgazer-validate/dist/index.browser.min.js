var jsPsychWebgazerValidate = (function (n) {
  "use strict";
  var m = {
    name: "@jspsych/plugin-webgazer-validate",
    version: "2.0.0",
    description: "",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest  --passWithNoTests",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-webgazer-validate",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/webgazer-validate",
    peerDependencies: { jspsych: ">=7.0.0", "@jspsych/extension-webgazer": ">=1.0.0" },
    devDependencies: {
      "@jspsych/config": "^3.0.0",
      "@jspsych/extension-webgazer": "^1.0.2",
      "@jspsych/test-utils": "^1.2.0",
    },
  };
  const b = {
    name: "webgazer-validate",
    version: m.version,
    parameters: {
      validation_points: {
        type: n.ParameterType.INT,
        default: [
          [10, 10],
          [10, 50],
          [10, 90],
          [50, 10],
          [50, 50],
          [50, 90],
          [90, 10],
          [90, 50],
          [90, 90],
        ],
        array: !0,
      },
      validation_point_coordinates: {
        type: n.ParameterType.SELECT,
        default: "percent",
        options: ["percent", "center-offset-pixels"],
      },
      roi_radius: { type: n.ParameterType.INT, default: 200 },
      randomize_validation_order: { type: n.ParameterType.BOOL, default: !1 },
      time_to_saccade: { type: n.ParameterType.INT, default: 1e3 },
      validation_duration: { type: n.ParameterType.INT, default: 2e3 },
      point_size: { type: n.ParameterType.INT, default: 20 },
      show_validation_data: { type: n.ParameterType.BOOL, default: !1 },
    },
    data: {
      raw_gaze: {
        type: n.ParameterType.COMPLEX,
        array: !0,
        nested: {
          x: { type: n.ParameterType.INT },
          y: { type: n.ParameterType.INT },
          dx: { type: n.ParameterType.INT },
          dy: { type: n.ParameterType.INT },
        },
      },
      percent_in_roi: { type: n.ParameterType.FLOAT, array: !0 },
      average_offset: { type: n.ParameterType.FLOAT, array: !0 },
      samples_per_sec: { type: n.ParameterType.FLOAT },
      validation_points: { type: n.ParameterType.INT, array: !0 },
    },
  };
  class f {
    constructor(v) {
      this.jsPsych = v;
    }
    trial(v, r) {
      const l = this.jsPsych.extensions.webgazer;
      var s = {};
      (s.raw_gaze = []),
        (s.percent_in_roi = []),
        (s.average_offset = []),
        (s.validation_points = null);
      var T = `
        <div id='webgazer-validate-container' style='position: relative; width:100vw; height:100vh; overflow: hidden;'>
        </div>`;
      v.innerHTML = T;
      var h = v.querySelector("#webgazer-validate-container"),
        _ = -1,
        u = null,
        $ = performance.now();
      const g = () => {
          l.stopSampleInterval(), this.jsPsych.finishTrial(s);
        },
        z = (t) => {
          var e = x(t[0], t[1]);
          h.innerHTML = e;
          var a = h.querySelector(".validation-point"),
            o = a.getBoundingClientRect(),
            i = o.left + o.width / 2,
            p = o.top + o.height / 2,
            d = performance.now() + r.time_to_saccade,
            H = d + r.validation_duration,
            w = [],
            D = l.onGazeUpdate((c) => {
              performance.now() > d &&
                w.push({ x: c.x, y: c.y, dx: c.x - i, dy: c.y - p, t: Math.round(c.t - $) });
            });
          requestAnimationFrame(function c() {
            performance.now() < H ? requestAnimationFrame(c) : (s.raw_gaze.push(w), D(), y());
          });
        },
        y = () => {
          if ((_++, _ == u.length)) I();
          else {
            var t = u[_];
            z(t);
          }
        },
        P = () => {
          r.randomize_validation_order
            ? (u = this.jsPsych.randomization.shuffle(r.validation_points))
            : (u = r.validation_points),
            (s.validation_points = u),
            (_ = -1),
            l.startSampleInterval(),
            y();
        },
        M = () => {
          for (var t = "", e = 0; e < r.validation_points.length; e++) {
            (t += x(r.validation_points[e][0], r.validation_points[e][1])),
              (t += k(r.validation_points[e][0], r.validation_points[e][1], 0, 0, r.roi_radius));
            for (var a = 0; a < s.raw_gaze[e].length; a++)
              t += S(
                r.validation_points[e][0],
                r.validation_points[e][1],
                s.raw_gaze[e][a].dx,
                s.raw_gaze[e][a].dy
              );
          }
          (t +=
            '<button id="cont" style="position:absolute; top: 50%; left:calc(50% - 50px); width: 100px;" class="jspsych-btn">Continue</btn>'),
            (h.innerHTML = t),
            h.querySelector("#cont").addEventListener("click", () => {
              l.pause(), g();
            }),
            l.showPredictions(),
            l.stopSampleInterval(),
            l.resume();
        },
        I = () => {
          s.samples_per_sec = B(s.raw_gaze).toFixed(2);
          for (var t = 0; t < r.validation_points.length; t++)
            (s.percent_in_roi[t] = E(s.raw_gaze[t])), (s.average_offset[t] = C(s.raw_gaze[t]));
          r.show_validation_data ? M() : g();
        };
      P();
      function x(t, e) {
        if (r.validation_point_coordinates == "percent") return L(t, e);
        if (r.validation_point_coordinates == "center-offset-pixels") return N(t, e);
      }
      function L(t, e) {
        return `<div class="validation-point" style="width:${r.point_size}px; height:${r.point_size}px; border-radius:${r.point_size}px; border: 1px solid #000; background-color: #333; position: absolute; left:${t}%; top:${e}%;"></div>`;
      }
      function N(t, e) {
        return `<div class="validation-point" style="width:${r.point_size}px; height:${
          r.point_size
        }px; border-radius:${
          r.point_size
        }px; border: 1px solid #000; background-color: #333; position: absolute; left:calc(50% - ${
          r.point_size / 2
        }px + ${t}px); top:calc(50% - ${r.point_size / 2}px + ${e}px);"></div>`;
      }
      function k(t, e, a, o, i) {
        if (r.validation_point_coordinates == "percent") return q(t, e, a, o, i);
        if (r.validation_point_coordinates == "center-offset-pixels") return O(t, e, a, o, i);
      }
      function q(t, e, a, o, i) {
        var p = `
          <div class="validation-centroid" style="width:${i * 2}px; height:${
          i * 2
        }px; border: 2px dotted #ccc; border-radius: ${i}px; background-color: transparent; position: absolute; left:calc(${t}% + ${
          a - i
        }px); top:calc(${e}% + ${o - i}px);"></div>
        `;
        return p;
      }
      function O(t, e, a, o, i) {
        var p = `
          <div class="validation-centroid" style="width:${i * 2}px; height:${
          i * 2
        }px; border: 2px dotted #ccc; border-radius: ${i}px; background-color: transparent; position: absolute; left:calc(50% + ${t}px + ${
          a - i
        }px); top:calc(50% + ${e}px + ${o - i}px);"></div>
        `;
        return p;
      }
      function S(t, e, a, o) {
        if (r.validation_point_coordinates == "percent") return j(t, e, a, o);
        if (r.validation_point_coordinates == "center-offset-pixels") return F(t, e, a, o);
      }
      function j(t, e, a, o) {
        var i = Math.sqrt(a * a + o * o) <= r.roi_radius ? "#afa" : "#faa";
        return `<div class="raw-data-point" style="width:5px; height:5px; border-radius:5px; background-color: ${i}; opacity:0.8; position: absolute; left:calc(${t}% + ${
          a - 2
        }px); top:calc(${e}% + ${o - 2}px);"></div>`;
      }
      function F(t, e, a, o) {
        var i = Math.sqrt(a * a + o * o) <= r.roi_radius ? "#afa" : "#faa";
        return `<div class="raw-data-point" style="width:5px; height:5px; border-radius:5px; background-color: ${i}; opacity:0.8; position: absolute; left:calc(50% + ${t}px + ${
          a - 2
        }px); top:calc(50% + ${e}px + ${o - 2}px);"></div>`;
      }
      function A(t) {
        var e = Math.floor(t.length / 2),
          a = t.sort((o, i) => o - i);
        return t.length % 2 == 0 ? a[e - 1] + a[e] / 2 : a[e];
      }
      function C(t) {
        var e = t.reduce((i, p, d) => ((i += p.dx), d == t.length - 1 ? i / t.length : i), 0),
          a = t.reduce((i, p, d) => ((i += p.dy), d == t.length - 1 ? i / t.length : i), 0),
          o = A(t.map((i) => Math.sqrt(Math.pow(i.dx - e, 2) + Math.pow(i.dy - a, 2))));
        return { x: e, y: a, r: o };
      }
      function E(t) {
        var e = t.map((i) => Math.sqrt(Math.pow(i.dx, 2) + Math.pow(i.dy, 2))),
          a = e.reduce((i, p) => (p <= r.roi_radius && i++, i), 0),
          o = (a / t.length) * 100;
        return o;
      }
      function B(t) {
        var e = [];
        if (t.length == 0) return 0;
        for (var a = 0; a < t.length; a++)
          if (t[a].length > 1) {
            for (var o = [], i = 1; i < t[a].length; i++) o.push(t[a][i].t - t[a][i - 1].t);
            e.push(o.reduce((p, d) => p + d, 0) / o.length);
          }
        return e.length > 0 ? 1e3 / (e.reduce((p, d) => p + d, 0) / e.length) : null;
      }
    }
  }
  return (f.info = b), f;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
