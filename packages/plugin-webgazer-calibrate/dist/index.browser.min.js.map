{"version":3,"file":"index.browser.min.js","sources":["../src/index.ts"],"sourcesContent":["import type WebGazerExtension from \"@jspsych/extension-webgazer\";\nimport { JsPsych, JsPsychPlugin, ParameterType, TrialType } from \"jspsych\";\n\nimport { version } from \"../package.json\";\n\nconst info = <const>{\n  name: \"webgazer-calibrate\",\n  version: version,\n  parameters: {\n    /** Array of points in `[x,y]` coordinates. Specified as a percentage of the screen width and height, from the left and top edge. The default grid is 9 points. */\n    calibration_points: {\n      type: ParameterType.INT, // TO DO: nested array, so different type?\n      default: [\n        [10, 10],\n        [10, 50],\n        [10, 90],\n        [50, 10],\n        [50, 50],\n        [50, 90],\n        [90, 10],\n        [90, 50],\n        [90, 90],\n      ],\n      array: true,\n    },\n    /** Can specify `click` to have participants click on calibration points or `view` to have participants passively watch calibration points.  */\n    calibration_mode: {\n      type: ParameterType.SELECT,\n      options: [\"click\", \"view\"],\n      default: \"click\",\n    },\n    /** Diameter of the calibration points in pixels. */\n    point_size: {\n      type: ParameterType.INT,\n      default: 20,\n    },\n    /** The number of times to repeat the sequence of calibration points. */\n    repetitions_per_point: {\n      type: ParameterType.INT,\n      default: 1,\n    },\n    /** Whether to randomize the order of the calibration points. */\n    randomize_calibration_order: {\n      type: ParameterType.BOOL,\n      default: false,\n    },\n    /** If `calibration_mode` is set to `view`, then this is the delay before calibrating after showing a point.\n     * Gives the participant time to fixate on the new target before assuming that the participant is looking at the target. */\n    time_to_saccade: {\n      type: ParameterType.INT,\n      default: 1000,\n    },\n    /**\n     * If `calibration_mode` is set to `view`, then this is the length of time to show a point while calibrating. Note\n     * that if `click` calibration is used then the point will remain on the screen until clicked.\n     */\n    time_per_point: {\n      type: ParameterType.INT,\n      default: 1000,\n    },\n  },\n  data: {\n    // no data collected\n  },\n};\n\ntype Info = typeof info;\n\n/**\n *\n * This plugin can be used to calibrate the [WebGazer extension](../extensions/webgazer.md). For a narrative\n * description of eye tracking with jsPsych, see the [eye tracking overview](../overview/eye-tracking.md).\n *\n * @author Josh de Leeuw\n * @see {@link https://www.jspsych.org/latest/plugins/webgazer-calibrate/ webgazer-calibrate plugin} and\n * {@link https://www.jspsych.org/latest/overview/eye-tracking/ eye-tracking overview} documentation on jspsych.org\n */\nclass WebgazerCalibratePlugin implements JsPsychPlugin<Info> {\n  static info = info;\n\n  constructor(private jsPsych: JsPsych) {}\n\n  trial(display_element: HTMLElement, trial: TrialType<Info>) {\n    const extension = this.jsPsych.extensions.webgazer as WebGazerExtension;\n\n    var html = `\n          <div id='webgazer-calibrate-container' style='position: relative; width:100vw; height:100vh'>\n          </div>`;\n\n    display_element.innerHTML = html;\n\n    var wg_container = display_element.querySelector(\"#webgazer-calibrate-container\");\n\n    var reps_completed = 0;\n    var points_completed = -1;\n    var cal_points = null;\n\n    const next_calibration_round = () => {\n      if (trial.randomize_calibration_order) {\n        cal_points = this.jsPsych.randomization.shuffle(trial.calibration_points);\n      } else {\n        cal_points = trial.calibration_points;\n      }\n      points_completed = -1;\n      next_calibration_point();\n    };\n\n    const calibrate = () => {\n      extension.resume();\n      if (trial.calibration_mode == \"click\") {\n        extension.startMouseCalibration();\n      }\n      next_calibration_round();\n    };\n\n    const next_calibration_point = () => {\n      points_completed++;\n      if (points_completed == cal_points.length) {\n        reps_completed++;\n        if (reps_completed == trial.repetitions_per_point) {\n          calibration_done();\n        } else {\n          next_calibration_round();\n        }\n      } else {\n        var pt = cal_points[points_completed];\n        calibration_display_gaze_only(pt);\n      }\n    };\n\n    const calibration_display_gaze_only = (pt) => {\n      var pt_html = `<div id=\"calibration-point\" style=\"width:${trial.point_size}px; height:${trial.point_size}px; border-radius:${trial.point_size}px; border: 1px solid #000; background-color: #333; position: absolute; left:${pt[0]}%; top:${pt[1]}%;\"></div>`;\n      wg_container.innerHTML = pt_html;\n\n      var pt_dom = wg_container.querySelector<HTMLElement>(\"#calibration-point\");\n\n      if (trial.calibration_mode == \"click\") {\n        pt_dom.style.cursor = \"pointer\";\n        pt_dom.addEventListener(\"click\", () => {\n          next_calibration_point();\n        });\n      }\n\n      if (trial.calibration_mode == \"view\") {\n        var br = pt_dom.getBoundingClientRect();\n        var x = br.left + br.width / 2;\n        var y = br.top + br.height / 2;\n\n        var pt_start_cal: number = performance.now() + trial.time_to_saccade;\n        var pt_finish: number = performance.now() + trial.time_to_saccade + trial.time_per_point;\n\n        const watch_dot = () => {\n          if (performance.now() > pt_start_cal) {\n            extension.calibratePoint(x, y);\n          }\n          if (performance.now() < pt_finish) {\n            requestAnimationFrame(watch_dot);\n          } else {\n            next_calibration_point();\n          }\n        };\n\n        requestAnimationFrame(watch_dot);\n      }\n    };\n\n    const calibration_done = () => {\n      if (trial.calibration_mode == \"click\") {\n        extension.stopMouseCalibration();\n      }\n      wg_container.innerHTML = \"\";\n      end_trial();\n    };\n\n    // function to end trial when it is time\n    const end_trial = () => {\n      extension.pause();\n      extension.hidePredictions();\n      extension.hideVideo();\n\n      // gather the data to store for the trial\n      var trial_data = {};\n\n      // move on to the next trial\n      this.jsPsych.finishTrial(trial_data);\n    };\n\n    calibrate();\n  }\n}\n\nexport default WebgazerCalibratePlugin;\n"],"names":["info","version","ParameterType","WebgazerCalibratePlugin","jsPsych","display_element","trial","extension","html","wg_container","reps_completed","points_completed","cal_points","next_calibration_round","next_calibration_point","calibrate","calibration_done","pt","calibration_display_gaze_only","pt_html","pt_dom","br","x","y","pt_start_cal","pt_finish","watch_dot","end_trial","trial_data"],"mappings":"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"}