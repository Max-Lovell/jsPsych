var jsPsychWebgazerCalibrate = (function (t) {
  "use strict";
  var m = {
    name: "@jspsych/plugin-webgazer-calibrate",
    version: "2.0.0",
    description: "",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest  --passWithNoTests",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-webgazer-calibrate",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/webgazer-calibrate",
    peerDependencies: { jspsych: ">=7.0.0", "@jspsych/extension-webgazer": ">=1.0.0" },
    devDependencies: {
      "@jspsych/config": "^3.0.0",
      "@jspsych/extension-webgazer": "^1.0.2",
      "@jspsych/test-utils": "^1.2.0",
    },
  };
  const y = {
    name: "webgazer-calibrate",
    version: m.version,
    parameters: {
      calibration_points: {
        type: t.ParameterType.INT,
        default: [
          [10, 10],
          [10, 50],
          [10, 90],
          [50, 10],
          [50, 50],
          [50, 90],
          [90, 10],
          [90, 50],
          [90, 90],
        ],
        array: !0,
      },
      calibration_mode: {
        type: t.ParameterType.SELECT,
        options: ["click", "view"],
        default: "click",
      },
      point_size: { type: t.ParameterType.INT, default: 20 },
      repetitions_per_point: { type: t.ParameterType.INT, default: 1 },
      randomize_calibration_order: { type: t.ParameterType.BOOL, default: !1 },
      time_to_saccade: { type: t.ParameterType.INT, default: 1e3 },
      time_per_point: { type: t.ParameterType.INT, default: 1e3 },
    },
    data: {},
  };
  class d {
    constructor(a) {
      this.jsPsych = a;
    }
    trial(a, e) {
      const i = this.jsPsych.extensions.webgazer;
      var g = `
          <div id='webgazer-calibrate-container' style='position: relative; width:100vw; height:100vh'>
          </div>`;
      a.innerHTML = g;
      var c = a.querySelector("#webgazer-calibrate-container"),
        u = 0,
        s = -1,
        n = null;
      const b = () => {
          e.randomize_calibration_order
            ? (n = this.jsPsych.randomization.shuffle(e.calibration_points))
            : (n = e.calibration_points),
            (s = -1),
            p();
        },
        _ = () => {
          i.resume(), e.calibration_mode == "click" && i.startMouseCalibration(), b();
        },
        p = () => {
          if ((s++, s == n.length)) u++, u == e.repetitions_per_point ? f() : b();
          else {
            var r = n[s];
            w(r);
          }
        },
        w = (r) => {
          var T = `<div id="calibration-point" style="width:${e.point_size}px; height:${e.point_size}px; border-radius:${e.point_size}px; border: 1px solid #000; background-color: #333; position: absolute; left:${r[0]}%; top:${r[1]}%;"></div>`;
          c.innerHTML = T;
          var l = c.querySelector("#calibration-point");
          if (
            (e.calibration_mode == "click" &&
              ((l.style.cursor = "pointer"),
              l.addEventListener("click", () => {
                p();
              })),
            e.calibration_mode == "view")
          ) {
            var o = l.getBoundingClientRect(),
              z = o.left + o.width / 2,
              P = o.top + o.height / 2,
              j = performance.now() + e.time_to_saccade,
              x = performance.now() + e.time_to_saccade + e.time_per_point;
            const h = () => {
              performance.now() > j && i.calibratePoint(z, P),
                performance.now() < x ? requestAnimationFrame(h) : p();
            };
            requestAnimationFrame(h);
          }
        },
        f = () => {
          e.calibration_mode == "click" && i.stopMouseCalibration(), (c.innerHTML = ""), v();
        },
        v = () => {
          i.pause(), i.hidePredictions(), i.hideVideo();
          var r = {};
          this.jsPsych.finishTrial(r);
        };
      _();
    }
  }
  return (d.info = y), d;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
