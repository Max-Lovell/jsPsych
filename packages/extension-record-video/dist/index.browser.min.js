var jsPsychExtensionRecordVideo = (function (l) {
  "use strict";
  function u(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  const p = (e) => {
    const r = new Set();
    do for (const t of Reflect.ownKeys(e)) r.add([e, t]);
    while ((e = Reflect.getPrototypeOf(e)) && e !== Object.prototype);
    return r;
  };
  var y = (e, { include: r, exclude: t } = {}) => {
      const a = (o) => {
        const s = (i) => (typeof i == "string" ? o === i : i.test(o));
        return r ? r.some(s) : t ? !t.some(s) : !0;
      };
      for (const [o, s] of p(e.constructor.prototype)) {
        if (s === "constructor" || !a(s)) continue;
        const i = Reflect.getOwnPropertyDescriptor(o, s);
        i && typeof i.value == "function" && (e[s] = e[s].bind(e));
      }
      return e;
    },
    m = u(y),
    v = {
      name: "@jspsych/extension-record-video",
      version: "1.1.0",
      description: "jsPsych extension for recording video",
      type: "module",
      main: "dist/index.cjs",
      exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
      typings: "dist/index.d.ts",
      unpkg: "dist/index.browser.min.js",
      files: ["src", "dist"],
      source: "src/index.ts",
      scripts: {
        test: "jest",
        "test:watch": "npm test -- --watch",
        tsc: "tsc",
        build: "rollup --config",
        "build:watch": "npm run build -- --watch",
      },
      repository: {
        type: "git",
        url: "git+https://github.com/jspsych/jsPsych.git",
        directory: "packages/extension-record-video",
      },
      author: "Josh de Leeuw",
      license: "MIT",
      bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
      homepage: "https://www.jspsych.org/latest/extensions/record-video",
      peerDependencies: { jspsych: ">=7.0.0" },
      devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
    },
    f = (e, r, t) =>
      new Promise((a, o) => {
        var s = (n) => {
            try {
              c(t.next(n));
            } catch (d) {
              o(d);
            }
          },
          i = (n) => {
            try {
              c(t.throw(n));
            } catch (d) {
              o(d);
            }
          },
          c = (n) => (n.done ? a(n.value) : Promise.resolve(n.value).then(s, i));
        c((t = t.apply(e, r)).next());
      });
  class h {
    constructor(r) {
      (this.jsPsych = r),
        (this.recordedChunks = []),
        (this.recorder = null),
        (this.currentTrialData = null),
        (this.trialComplete = !1),
        (this.onUpdateCallback = null),
        (this.initialize = () => f(this, null, function* () {})),
        (this.on_start = () => {
          if (
            ((this.recorder = this.jsPsych.pluginAPI.getCameraRecorder()),
            (this.recordedChunks = []),
            (this.trialComplete = !1),
            (this.currentTrialData = {}),
            !this.recorder)
          ) {
            console.warn(
              "The record-video extension is trying to start but the camera is not initialized. Do you need to run the initialize-camera plugin?"
            );
            return;
          }
          this.recorder.addEventListener("dataavailable", this.handleOnDataAvailable);
        }),
        (this.on_load = () => {
          this.recorder.start();
        }),
        (this.on_finish = () =>
          new Promise((t) => {
            (this.trialComplete = !0),
              this.recorder.stop(),
              this.currentTrialData.record_video_data
                ? t(this.currentTrialData)
                : (this.onUpdateCallback = () => {
                    t(this.currentTrialData);
                  });
          })),
        m(this);
    }
    handleOnDataAvailable(r) {
      r.data.size > 0 &&
        (console.log("chunks added"),
        this.recordedChunks.push(r.data),
        this.trialComplete && this.updateData());
    }
    updateData() {
      const r = new Blob(this.recordedChunks, { type: this.recorder.mimeType }),
        t = new FileReader();
      t.addEventListener("load", () => {
        const a = t.result.split(",")[1];
        (this.currentTrialData.record_video_data = a),
          this.onUpdateCallback && this.onUpdateCallback();
      }),
        t.readAsDataURL(r);
    }
  }
  return (
    (h.info = {
      name: "record-video",
      version: v.version,
      data: { record_video_data: { type: l.ParameterType.STRING } },
    }),
    h
  );
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
