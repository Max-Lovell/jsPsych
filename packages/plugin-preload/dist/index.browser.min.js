var jsPsychPreload = (function (t) {
  "use strict";
  var O = {
    name: "@jspsych/plugin-preload",
    version: "2.0.0",
    description: "",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-preload",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/preload",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: {
      "@jspsych/config": "^3.0.0",
      "@jspsych/plugin-audio-keyboard-response": "*",
      "@jspsych/plugin-image-keyboard-response": "*",
      "@jspsych/plugin-video-keyboard-response": "*",
    },
  };
  const S = {
    name: "preload",
    version: O.version,
    parameters: {
      auto_preload: { type: t.ParameterType.BOOL, default: !1 },
      trials: { type: t.ParameterType.TIMELINE, default: [] },
      images: { type: t.ParameterType.STRING, default: [], array: !0 },
      audio: { type: t.ParameterType.STRING, default: [], array: !0 },
      video: { type: t.ParameterType.STRING, default: [], array: !0 },
      message: { type: t.ParameterType.HTML_STRING, default: null },
      show_progress_bar: { type: t.ParameterType.BOOL, default: !0 },
      continue_after_error: { type: t.ParameterType.BOOL, default: !1 },
      error_message: {
        type: t.ParameterType.HTML_STRING,
        default: "The experiment failed to load.",
      },
      show_detailed_errors: { type: t.ParameterType.BOOL, default: !1 },
      max_load_time: { type: t.ParameterType.INT, default: null },
      on_error: { type: t.ParameterType.FUNCTION, default: null },
      on_success: { type: t.ParameterType.FUNCTION, default: null },
    },
    data: {
      success: { type: t.ParameterType.BOOL },
      timeout: { type: t.ParameterType.BOOL },
      failed_images: { type: t.ParameterType.STRING, array: !0 },
      failed_audio: { type: t.ParameterType.STRING, array: !0 },
      failed_video: { type: t.ParameterType.STRING, array: !0 },
    },
  };
  class I {
    constructor(s) {
      this.jsPsych = s;
    }
    trial(s, e) {
      var a = null,
        d = !1,
        j = [],
        w = [],
        A = [],
        y = [],
        k = this.jsPsych.getSafeModeStatus(),
        o = [],
        l = [],
        i = [];
      if (e.auto_preload) {
        var M = this.jsPsych.getTimeline(),
          m = this.jsPsych.pluginAPI.getAutoPreloadList(M);
        (o = o.concat(m.images)), (l = l.concat(m.audio)), (i = i.concat(m.video));
      }
      if (e.trials.length > 0) {
        var P = this.jsPsych.pluginAPI.getAutoPreloadList(e.trials);
        (o = o.concat(P.images)), (l = l.concat(P.audio)), (i = i.concat(P.video));
      }
      (o = o.concat(e.images)),
        (l = l.concat(e.audio)),
        (i = i.concat(e.video)),
        (o = this.jsPsych.utils.unique(o.flat())),
        (l = this.jsPsych.utils.unique(l.flat())),
        (i = this.jsPsych.utils.unique(i.flat())),
        k && (i = []);
      var f = "";
      e.message !== null && (f += e.message),
        e.show_progress_bar &&
          (f += `
            <div id='jspsych-loading-progress-bar-container' style='height: 10px; width: 300px; background-color: #ddd; margin: auto;'>
              <div id='jspsych-loading-progress-bar' style='height: 10px; width: 0%; background-color: #777;'></div>
            </div>`),
        (s.innerHTML = f);
      const L = () => {
          if ((g++, e.show_progress_bar)) {
            var r = (g / c) * 100,
              n = s.querySelector("#jspsych-loading-progress-bar");
            n !== null && (n.style.width = r + "%");
          }
        },
        N = () => {
          typeof d != "undefined" &&
            d === !1 &&
            (this.jsPsych.pluginAPI.clearAllTimeouts(),
            this.jsPsych.pluginAPI.cancelPreloads(),
            (a = !0),
            h());
        },
        R = () => {
          this.jsPsych.pluginAPI.cancelPreloads(),
            typeof a != "undefined" &&
              (a === !1 || a === null) &&
              ((d = !0),
              T < c && (a = !1),
              x("timeout"),
              y.push(
                "<p><strong>Loading timed out.</strong><br>Consider compressing your stimuli files, loading your files in smaller batches,<br>and/or increasing the <i>max_load_time</i> parameter.</p>"
              ),
              e.continue_after_error ? h() : _());
        },
        _ = () => {
          this.jsPsych.pluginAPI.clearAllTimeouts(),
            this.jsPsych.pluginAPI.cancelPreloads(),
            (s.innerHTML = e.error_message),
            e.show_detailed_errors &&
              ((s.innerHTML += "<p><strong>Error details:</strong></p>"),
              y.forEach((r) => {
                s.innerHTML += r;
              }));
        },
        h = () => {
          var r = { success: a, timeout: d, failed_images: j, failed_audio: w, failed_video: A };
          this.jsPsych.finishTrial(r);
        };
      e.max_load_time !== null && this.jsPsych.pluginAPI.setTimeout(R, e.max_load_time);
      var c = o.length + l.length + i.length,
        g = 0,
        T = 0;
      if (c == 0) N();
      else {
        const r = (p) => {
            this.jsPsych.pluginAPI.preloadVideo(i, p, v, b);
          },
          n = (p) => {
            this.jsPsych.pluginAPI.preloadAudio(l, p, v, b);
          },
          u = (p) => {
            this.jsPsych.pluginAPI.preloadImages(o, p, v, b);
          };
        i.length > 0 && r(() => {}), l.length > 0 && n(() => {}), o.length > 0 && u(() => {});
      }
      function b(r) {
        L(), a == null && (a = !1);
        var n = "unknown file";
        r.source && (n = r.source),
          r.error &&
            r.error.path &&
            r.error.path.length > 0 &&
            (r.error.path[0].localName == "img"
              ? j.push(n)
              : r.error.path[0].localName == "audio"
              ? w.push(n)
              : r.error.path[0].localName == "video" && A.push(n));
        var u = "<p><strong>Error loading file: " + n + "</strong><br>";
        r.error.statusText && (u += "File request response status: " + r.error.statusText + "<br>"),
          r.error == "404" && (u += "404 - file not found.<br>"),
          typeof r.error.loaded != "undefined" && r.error.loaded !== null && r.error.loaded !== 0
            ? (u += r.error.loaded + " bytes transferred.")
            : (u +=
                "File did not begin loading. Check that file path is correct and reachable by the browser,<br>and that loading is not blocked by cross-origin resource sharing (CORS) errors."),
          (u += "</p>"),
          y.push(u),
          x(n),
          g == c && (e.continue_after_error ? h() : _());
      }
      function v(r) {
        L(), G(r), T++, T == c ? N() : g == c && (e.continue_after_error ? h() : _());
      }
      function x(r) {
        e.on_error !== null && e.on_error(r);
      }
      function G(r) {
        e.on_success !== null && e.on_success(r);
      }
    }
    simulate(s, e, a, d) {
      e == "data-only" && (d(), this.simulate_data_only(s, a)),
        e == "visual" && this.simulate_visual(s, a, d);
    }
    create_simulation_data(s, e) {
      const a = { success: !0, timeout: !1, failed_images: [], failed_audio: [], failed_video: [] };
      return this.jsPsych.pluginAPI.mergeSimulationData(a, e);
    }
    simulate_data_only(s, e) {
      const a = this.create_simulation_data(s, e);
      this.jsPsych.finishTrial(a);
    }
    simulate_visual(s, e, a) {
      const d = this.jsPsych.getDisplayElement();
      this.trial(d, s), a();
    }
  }
  return (I.info = S), I;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
