var jsPsychExtensionWebgazer = (function (r) {
  "use strict";
  var l = {
    name: "@jspsych/extension-webgazer",
    version: "1.1.0",
    description: "jsPsych extension for eye tracking using WebGazer.js",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest --passWithNoTests",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/extension-webgazer",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/extensions/webgazer",
    peerDependencies: { jspsych: ">=7.0.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  class a {
    constructor(d) {
      (this.jsPsych = d),
        (this.currentTrialData = []),
        (this.currentTrialTargets = {}),
        (this.initialized = !1),
        (this.activeTrial = !1),
        (this.initialize = ({
          round_predictions: e = !0,
          auto_initialize: i = !1,
          sampling_interval: t = 34,
          webgazer: s,
        }) => (
          (this.round_predictions = e),
          (this.sampling_interval = t),
          (this.gazeUpdateCallbacks = []),
          (this.domObserver = new MutationObserver(this.mutationObserverCallback)),
          new Promise((n, h) => {
            typeof s == "undefined"
              ? window.webgazer
                ? (this.webgazer = window.webgazer)
                : h(
                    new Error(
                      "Webgazer extension failed to initialize. webgazer.js not loaded. Load webgazer.js before calling initJsPsych()"
                    )
                  )
              : (this.webgazer = s),
              this.hideVideo(),
              this.hidePredictions(),
              i
                ? this.webgazer
                    .begin()
                    .then(() => {
                      (this.initialized = !0), this.stopMouseCalibration(), this.pause(), n();
                    })
                    .catch((o) => {
                      console.error(o), h(o);
                    })
                : n();
          })
        )),
        (this.on_start = (e) => {
          (this.currentTrialData = []),
            (this.currentTrialTargets = {}),
            (this.currentTrialSelectors = e.targets),
            this.domObserver.observe(this.jsPsych.getDisplayElement(), { childList: !0 });
        }),
        (this.on_load = () => {
          (this.currentTrialStart = performance.now()),
            this.startSampleInterval(),
            (this.activeTrial = !0);
        }),
        (this.on_finish = () => (
          this.stopSampleInterval(),
          this.domObserver.disconnect(),
          (this.activeTrial = !1),
          { webgazer_data: this.currentTrialData, webgazer_targets: this.currentTrialTargets }
        )),
        (this.start = () =>
          new Promise((e, i) => {
            if (typeof this.webgazer == "undefined") {
              const t =
                "Failed to start webgazer. Things to check: Is webgazer.js loaded? Is the webgazer extension included in initJsPsych?";
              console.error(t), i(t);
            }
            this.webgazer
              .begin()
              .then(() => {
                (this.initialized = !0), this.stopMouseCalibration(), this.pause(), e();
              })
              .catch((t) => {
                console.error(t), i(t);
              });
          })),
        (this.startSampleInterval = (e = this.sampling_interval) => {
          (this.gazeInterval = setInterval(() => {
            this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);
          }, e)),
            this.webgazer.getCurrentPrediction().then(this.handleGazeDataUpdate);
        }),
        (this.stopSampleInterval = () => {
          clearInterval(this.gazeInterval);
        }),
        (this.isInitialized = () => this.initialized),
        (this.faceDetected = () => this.webgazer.getTracker().predictionReady),
        (this.showPredictions = () => {
          this.webgazer.showPredictionPoints(!0);
        }),
        (this.hidePredictions = () => {
          this.webgazer.showPredictionPoints(!1);
        }),
        (this.showVideo = () => {
          this.webgazer.showVideo(!0),
            this.webgazer.showFaceOverlay(!0),
            this.webgazer.showFaceFeedbackBox(!0);
        }),
        (this.hideVideo = () => {
          this.webgazer.showVideo(!1),
            this.webgazer.showFaceOverlay(!1),
            this.webgazer.showFaceFeedbackBox(!1);
        }),
        (this.resume = () => {
          this.webgazer.resume();
        }),
        (this.pause = () => {
          this.webgazer.pause(),
            document.querySelector("#webgazerGazeDot") &&
              (document.querySelector("#webgazerGazeDot").style.display = "none");
        }),
        (this.resetCalibration = () => {
          this.webgazer.clearData();
        }),
        (this.stopMouseCalibration = () => {
          this.webgazer.removeMouseEventListeners();
        }),
        (this.startMouseCalibration = () => {
          this.webgazer.addMouseEventListeners();
        }),
        (this.calibratePoint = (e, i) => {
          this.webgazer.recordScreenPosition(e, i, "click");
        }),
        (this.setRegressionType = (e) => {
          var i = ["ridge", "weightedRidge", "threadedRidge"];
          i.includes(e)
            ? this.webgazer.setRegression(e)
            : console.warn(
                "Invalid regression_type parameter for webgazer.setRegressionType. Valid options are ridge, weightedRidge, and threadedRidge."
              );
        }),
        (this.getCurrentPrediction = () => this.webgazer.getCurrentPrediction()),
        (this.onGazeUpdate = (e) => (
          this.gazeUpdateCallbacks.push(e),
          () => {
            this.gazeUpdateCallbacks = this.gazeUpdateCallbacks.filter((i) => i !== e);
          }
        )),
        (this.handleGazeDataUpdate = (e, i) => {
          if (e !== null) {
            var t = {
              x: this.round_predictions ? Math.round(e.x) : e.x,
              y: this.round_predictions ? Math.round(e.y) : e.y,
              t: e.t,
            };
            this.activeTrial &&
              ((t.t = Math.round(e.t - this.currentTrialStart)), this.currentTrialData.push(t)),
              (this.currentGaze = t);
            for (var s = 0; s < this.gazeUpdateCallbacks.length; s++)
              this.gazeUpdateCallbacks[s](t);
          } else this.currentGaze = null;
        }),
        (this.mutationObserverCallback = (e, i) => {
          for (const s of this.currentTrialSelectors)
            if (!this.currentTrialTargets[s] && this.jsPsych.getDisplayElement().querySelector(s)) {
              var t = this.jsPsych.getDisplayElement().querySelector(s).getBoundingClientRect();
              this.currentTrialTargets[s] = t;
            }
        });
    }
  }
  return (
    (a.info = {
      name: "webgazer",
      version: l.version,
      data: {
        webgazer_data: { type: r.ParameterType.INT, array: !0 },
        webgazer_targets: {
          type: r.ParameterType.COMPLEX,
          nested: {
            x: { type: r.ParameterType.INT },
            y: { type: r.ParameterType.INT },
            width: { type: r.ParameterType.INT },
            height: { type: r.ParameterType.INT },
            top: { type: r.ParameterType.INT },
            bottom: { type: r.ParameterType.INT },
            left: { type: r.ParameterType.INT },
            right: { type: r.ParameterType.INT },
          },
        },
      },
    }),
    a
  );
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
