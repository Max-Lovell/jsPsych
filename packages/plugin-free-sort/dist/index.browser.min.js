var jsPsychFreeSort = (function (t) {
  "use strict";
  var E = {
    name: "@jspsych/plugin-free-sort",
    version: "2.0.0",
    description: "jsPsych plugin for drag-and-drop sorting of a collection of images",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-free-sort",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/free-sort",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  function q(a) {
    let r = a.length,
      e,
      i;
    for (; r !== 0; )
      (i = Math.floor(Math.random() * r)), (r -= 1), (e = a[r]), (a[r] = a[i]), (a[i] = e);
    return a;
  }
  function x(a, r, e) {
    const i = (r - a) / (e - 1);
    let n = [];
    for (let l = 0; l < e; l++) n.push(a + i * l);
    return n;
  }
  function j(a, r, e, i, n, l, d = !1) {
    return d
      ? Math.abs(a - e) <= n && Math.abs(r - i) <= l
      : (a - e) * (a - e) * (l * l) + (r - i) * (r - i) * (n * n) <= n * n * (l * l);
  }
  function G(a, r) {
    const e = Math.floor(Math.random() * (a - 1)),
      i = Math.floor(Math.random() * (r - 1));
    return { x: e, y: i };
  }
  const C = {
    name: "free-sort",
    version: E.version,
    parameters: {
      stimuli: { type: t.ParameterType.IMAGE, default: void 0, array: !0 },
      stim_height: { type: t.ParameterType.INT, default: 100 },
      stim_width: { type: t.ParameterType.INT, default: 100 },
      scale_factor: { type: t.ParameterType.FLOAT, default: 1.5 },
      sort_area_height: { type: t.ParameterType.INT, default: 700 },
      sort_area_width: { type: t.ParameterType.INT, default: 700 },
      sort_area_shape: {
        type: t.ParameterType.SELECT,
        options: ["square", "ellipse"],
        default: "ellipse",
      },
      prompt: { type: t.ParameterType.HTML_STRING, default: "" },
      prompt_location: {
        type: t.ParameterType.SELECT,
        options: ["above", "below"],
        default: "above",
      },
      button_label: { type: t.ParameterType.STRING, default: "Continue" },
      change_border_background_color: { type: t.ParameterType.BOOL, default: !0 },
      border_color_in: { type: t.ParameterType.STRING, default: "#a1d99b" },
      border_color_out: { type: t.ParameterType.STRING, default: "#fc9272" },
      border_width: { type: t.ParameterType.INT, default: null },
      counter_text_unfinished: {
        type: t.ParameterType.HTML_STRING,
        default: "You still need to place %n% item%s% inside the sort area.",
      },
      counter_text_finished: {
        type: t.ParameterType.HTML_STRING,
        default: "All items placed. Feel free to reposition items if necessary.",
      },
      stim_starts_inside: { type: t.ParameterType.BOOL, default: !1 },
      column_spread_factor: { type: t.ParameterType.FLOAT, default: 1 },
    },
    data: {
      init_locations: { type: t.ParameterType.STRING, array: !0 },
      moves: {
        type: t.ParameterType.COMPLEX,
        array: !0,
        parameters: {
          src: { type: t.ParameterType.STRING },
          x: { type: t.ParameterType.INT },
          y: { type: t.ParameterType.INT },
        },
      },
      final_locations: {
        type: t.ParameterType.COMPLEX,
        array: !0,
        parameters: {
          src: { type: t.ParameterType.STRING },
          x: { type: t.ParameterType.INT },
          y: { type: t.ParameterType.INT },
        },
      },
      rt: { type: t.ParameterType.INT },
    },
  };
  class P {
    constructor(r) {
      this.jsPsych = r;
    }
    trial(r, e) {
      var i = performance.now(),
        n = e.border_color_out,
        l = e.border_width,
        d = e.stimuli;
      e.change_border_background_color == !1 && (n = "#000000"),
        e.border_width == null && (l = e.sort_area_height * 0.03);
      let _ =
        '<div id="jspsych-free-sort-arena" class="jspsych-free-sort-arena" style="position: relative; width:' +
        e.sort_area_width +
        "px; height:" +
        e.sort_area_height +
        'px; margin: auto;"</div>';
      (_ +=
        '<div id="jspsych-free-sort-border" class="jspsych-free-sort-border" style="position: relative; width:' +
        e.sort_area_width * 0.94 +
        "px; height:" +
        e.sort_area_height * 0.94 +
        "px; border:" +
        l +
        "px solid " +
        n +
        "; margin: auto; line-height: 0em; "),
        e.sort_area_shape == "ellipse"
          ? (_ += 'webkit-border-radius: 50%; moz-border-radius: 50%; border-radius: 50%"></div>')
          : (_ += 'webkit-border-radius: 0%; moz-border-radius: 0%; border-radius: 0%"></div>');
      const M =
        '<div style="line-height: 1.0em;">' +
        e.prompt +
        '<p id="jspsych-free-sort-counter" style="display: inline-block;">' +
        k(d.length) +
        "</p></div>";
      e.prompt_location == "below" ? (_ += M) : (_ = M + _),
        (_ +=
          '<div><button id="jspsych-free-sort-done-btn" class="jspsych-btn" style="margin-top: 5px; margin-bottom: 15px; visibility: hidden;">' +
          e.button_label +
          "</button></div>"),
        (r.innerHTML = _);
      let L = [];
      if (!e.stim_starts_inside) {
        let o = Math.ceil(Math.sqrt(d.length));
        o % 2 != 0 && (o = o + 1);
        var g = [],
          u = [];
        for (const h of x(0, e.sort_area_width - e.stim_width, o))
          for (const s of x(0, e.sort_area_height - e.stim_height, o))
            h > (e.sort_area_width - e.stim_width) * 0.5
              ? g.push({ x: h + e.sort_area_width * (0.5 * e.column_spread_factor), y: s })
              : u.push({ x: h - e.sort_area_width * (0.5 * e.column_spread_factor), y: s });
        for (; g.length + u.length < d.length; ) (g = g.concat(g)), (u = u.concat(u));
        (u = u.reverse()), (d = q(d));
      }
      for (let o = 0; o < d.length; o++) {
        var f;
        e.stim_starts_inside
          ? (f = G(e.sort_area_width - e.stim_width, e.sort_area_height - e.stim_height))
          : o % 2 == 0
          ? (f = g[Math.floor(o * 0.5)])
          : (f = u[Math.floor(o * 0.5)]),
          (r.querySelector("#jspsych-free-sort-arena").innerHTML +=
            '<img src="' +
            d[o] +
            '" data-src="' +
            d[o] +
            '" class="jspsych-free-sort-draggable" draggable="false" id="jspsych-free-sort-draggable-' +
            o +
            '" style="position: absolute; cursor: move; width:' +
            e.stim_width +
            "px; height:" +
            e.stim_height +
            "px; top:" +
            f.y +
            "px; left:" +
            f.x +
            'px;"></img>'),
          L.push({ src: d[o], x: f.x, y: f.y });
      }
      const y = d.map(() => e.stim_starts_inside),
        I = [];
      let T = !1;
      const R = Array.prototype.slice.call(r.querySelectorAll(".jspsych-free-sort-draggable")),
        c = r.querySelector("#jspsych-free-sort-border"),
        v = r.querySelector("#jspsych-free-sort-done-btn");
      y.some(Boolean) &&
        e.change_border_background_color &&
        (c.style.borderColor = e.border_color_in),
        y.every(Boolean) &&
          (e.change_border_background_color && (c.style.background = e.border_color_in),
          (v.style.visibility = "visible"),
          (r.querySelector("#jspsych-free-sort-counter").innerHTML = e.counter_text_finished));
      for (const o of R)
        o.addEventListener("pointerdown", function ({ clientX: h, clientY: s }) {
          let p = h - this.offsetLeft,
            b = s - this.offsetTop - window.scrollY;
          this.style.transform = "scale(" + e.scale_factor + "," + e.scale_factor + ")";
          const m = ({ clientX: w, clientY: N }) => {
            (T = j(
              w - p,
              N - b,
              e.sort_area_width * 0.5 - e.stim_width * 0.5,
              e.sort_area_height * 0.5 - e.stim_height * 0.5,
              e.sort_area_width * 0.5,
              e.sort_area_height * 0.5,
              e.sort_area_shape == "square"
            )),
              (this.style.top =
                Math.min(
                  e.sort_area_height - e.stim_height * 0.5,
                  Math.max(-e.stim_height * 0.5, N - b)
                ) + "px"),
              (this.style.left =
                Math.min(
                  e.sort_area_width * 1.5 - e.stim_width,
                  Math.max(-e.sort_area_width * 0.5, w - p)
                ) + "px"),
              e.change_border_background_color &&
                (T
                  ? ((c.style.borderColor = e.border_color_in), (c.style.background = "None"))
                  : ((c.style.borderColor = n), (c.style.background = "None")));
            var B = parseInt(this.id.split("jspsych-free-sort-draggable-")[1], 10);
            y.splice(B, 1, T),
              y.every(Boolean)
                ? (e.change_border_background_color && (c.style.background = e.border_color_in),
                  (v.style.visibility = "visible"),
                  (r.querySelector("#jspsych-free-sort-counter").innerHTML =
                    e.counter_text_finished))
                : ((c.style.background = "none"),
                  (v.style.visibility = "hidden"),
                  (r.querySelector("#jspsych-free-sort-counter").innerHTML = k(
                    y.length - y.filter(Boolean).length
                  )));
          };
          document.addEventListener("pointermove", m);
          const S = (w) => {
            document.removeEventListener("pointermove", m),
              (this.style.transform = "scale(1, 1)"),
              e.change_border_background_color &&
                (y.every(Boolean)
                  ? ((c.style.background = e.border_color_in),
                    (c.style.borderColor = e.border_color_in))
                  : ((c.style.background = "none"), (c.style.borderColor = n))),
              I.push({ src: this.dataset.src, x: this.offsetLeft, y: this.offsetTop }),
              document.removeEventListener("pointerup", S);
          };
          document.addEventListener("pointerup", S);
        });
      r.querySelector("#jspsych-free-sort-done-btn").addEventListener("click", () => {
        if (y.every(Boolean)) {
          const o = performance.now(),
            h = Math.round(o - i),
            s = r.querySelectorAll(".jspsych-free-sort-draggable");
          let p = [];
          for (let m = 0; m < s.length; m++)
            p.push({
              src: s[m].dataset.src,
              x: parseInt(s[m].style.left),
              y: parseInt(s[m].style.top),
            });
          const b = { init_locations: L, moves: I, final_locations: p, rt: h };
          this.jsPsych.finishTrial(b);
        }
      });
      function k(o) {
        for (var h = "", s = e.counter_text_unfinished.split("%"), p = 0; p < s.length; p++)
          p % 2 === 0
            ? (h += s[p])
            : s[p] == "n"
            ? (h += o.toString())
            : s[p] == "s" && o > 1 && (h += "s");
        return h;
      }
    }
  }
  return (P.info = C), P;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
