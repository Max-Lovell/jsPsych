var jsPsychVisualSearchCircle = (function (s) {
  "use strict";
  var d = {
    name: "@jspsych/plugin-visual-search-circle",
    version: "2.0.0",
    description: "jsPsych visual search circle plugin",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-visual-search-circle",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/visual-search-circle",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const m = {
    name: "visual-search-circle",
    version: d.version,
    parameters: {
      target: { type: s.ParameterType.IMAGE, default: null },
      foil: { type: s.ParameterType.IMAGE, default: null },
      set_size: { type: s.ParameterType.INT, default: null },
      stimuli: { type: s.ParameterType.IMAGE, default: [], array: !0 },
      target_present: { type: s.ParameterType.BOOL, default: void 0 },
      fixation_image: { type: s.ParameterType.IMAGE, default: void 0 },
      target_size: { type: s.ParameterType.INT, array: !0, default: [50, 50] },
      fixation_size: { type: s.ParameterType.INT, array: !0, default: [16, 16] },
      circle_diameter: { type: s.ParameterType.INT, default: 250 },
      target_present_key: { type: s.ParameterType.KEY, default: "j" },
      target_absent_key: { type: s.ParameterType.KEY, default: "f" },
      trial_duration: { type: s.ParameterType.INT, default: null },
      fixation_duration: { type: s.ParameterType.INT, default: 1e3 },
      response_ends_trial: { type: s.ParameterType.BOOL, default: !0 },
    },
    data: {
      correct: { type: s.ParameterType.BOOL },
      response: { type: s.ParameterType.STRING },
      rt: { type: s.ParameterType.INT },
      set_size: { type: s.ParameterType.INT },
      target_present: { type: s.ParameterType.BOOL },
      locations: { type: s.ParameterType.INT, array: !0 },
    },
  };
  class g {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, t) {
      var r = t.circle_diameter + t.target_size[0],
        a = this.generateFixationLoc(t),
        n = this.generatePresentationSet(t),
        l = this.generateDisplayLocs(n.length, t);
      e.innerHTML +=
        '<div id="jspsych-visual-search-circle-container" style="position: relative; width:' +
        r +
        "px; height:" +
        r +
        'px"></div>';
      var c = e.querySelector("#jspsych-visual-search-circle-container");
      const h = () => {
          (c.innerHTML +=
            "<img src='" +
            t.fixation_image +
            "' style='position: absolute; top:" +
            a[0] +
            "px; left:" +
            a[1] +
            "px; width:" +
            t.fixation_size[0] +
            "px; height:" +
            t.fixation_size[1] +
            "px;'></img>"),
            this.jsPsych.pluginAPI.setTimeout(() => {
              u();
            }, t.fixation_duration);
        },
        o = { rt: null, key: null, correct: !1 },
        p = () => {
          this.jsPsych.pluginAPI.cancelAllKeyboardResponses();
          const i = {
            correct: o.correct,
            rt: o.rt,
            response: o.key,
            locations: l,
            target_present: t.target_present,
            set_size: t.set_size,
          };
          this.jsPsych.finishTrial(i);
        };
      h();
      const u = () => {
        for (var i = 0; i < l.length; i++)
          c.innerHTML +=
            "<img src='" +
            n[i] +
            "' style='position: absolute; top:" +
            l[i][0] +
            "px; left:" +
            l[i][1] +
            "px; width:" +
            t.target_size[0] +
            "px; height:" +
            t.target_size[1] +
            "px;'></img>";
        const P = (y) => {
            var _ = !1;
            ((this.jsPsych.pluginAPI.compareKeys(y.key, t.target_present_key) &&
              t.target_present) ||
              (this.jsPsych.pluginAPI.compareKeys(y.key, t.target_absent_key) &&
                !t.target_present)) &&
              (_ = !0),
              (o.rt = y.rt),
              (o.key = y.key),
              (o.correct = _),
              t.response_ends_trial && p();
          },
          f = [t.target_present_key, t.target_absent_key],
          T = this.jsPsych.pluginAPI.getKeyboardResponse({
            callback_function: P,
            valid_responses: f,
            rt_method: "performance",
            persist: !1,
            allow_held_key: !1,
          });
        t.trial_duration !== null &&
          this.jsPsych.pluginAPI.setTimeout(() => {
            o.rt || this.jsPsych.pluginAPI.cancelKeyboardResponse(T), p();
          }, t.trial_duration);
      };
    }
    generateFixationLoc(e) {
      var t = e.circle_diameter + e.target_size[0];
      return [
        Math.floor(t / 2 - e.fixation_size[0] / 2),
        Math.floor(t / 2 - e.fixation_size[1] / 2),
      ];
    }
    generateDisplayLocs(e, t) {
      for (
        var r = t.circle_diameter,
          a = r / 2,
          n = r + t.target_size[0],
          l = t.target_size[0],
          c = t.target_size[1],
          h = l / 2,
          o = c / 2,
          p = [],
          u = Math.floor(Math.random() * 360),
          i = 0;
        i < e;
        i++
      )
        p.push([
          Math.floor(n / 2 + this.cosd(u + i * (360 / e)) * a - o),
          Math.floor(n / 2 - this.sind(u + i * (360 / e)) * a - h),
        ]);
      return p;
    }
    generatePresentationSet(e) {
      var t = [];
      if (e.target !== null && e.foil !== null && e.set_size !== null)
        if (e.target_present) {
          for (var r = 0; r < e.set_size - 1; r++) t.push(e.foil);
          t.push(e.target);
        } else for (var r = 0; r < e.set_size; r++) t.push(e.foil);
      else
        e.stimuli.length > 0
          ? (t = e.stimuli)
          : console.error(
              "Error in visual-search-circle plugin: you must specify an array of images via the stimuli parameter OR specify the target, foil and set_size parameters."
            );
      return t;
    }
    cosd(e) {
      return Math.cos((e / 180) * Math.PI);
    }
    sind(e) {
      return Math.sin((e / 180) * Math.PI);
    }
    simulate(e, t, r, a) {
      t == "data-only" && (a(), this.simulate_data_only(e, r)),
        t == "visual" && this.simulate_visual(e, r, a);
    }
    create_simulation_data(e, t) {
      const r = this.jsPsych.pluginAPI.getValidKey([e.target_present_key, e.target_absent_key]),
        a = this.generatePresentationSet(e),
        n = {
          correct: e.target_present ? r == e.target_present_key : r == e.target_absent_key,
          response: r,
          rt: this.jsPsych.randomization.sampleExGaussian(500, 50, 1 / 150, !0),
          set_size: a.length,
          target_present: e.target_present,
          locations: this.generateDisplayLocs(a.length, e),
        },
        l = this.jsPsych.pluginAPI.mergeSimulationData(n, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, l), l;
    }
    simulate_data_only(e, t) {
      const r = this.create_simulation_data(e, t);
      this.jsPsych.finishTrial(r);
    }
    simulate_visual(e, t, r) {
      const a = this.create_simulation_data(e, t),
        n = this.jsPsych.getDisplayElement();
      this.trial(n, e),
        r(),
        a.rt !== null && this.jsPsych.pluginAPI.pressKey(a.response, e.fixation_duration + a.rt);
    }
  }
  return (g.info = m), g;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
