var jsPsychAudioKeyboardResponse = (function (o) {
  "use strict";
  function c(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
  }
  const y = (s) => {
    const e = new Set();
    do for (const t of Reflect.ownKeys(s)) e.add([s, t]);
    while ((s = Reflect.getPrototypeOf(s)) && s !== Object.prototype);
    return e;
  };
  var _ = (s, { include: e, exclude: t } = {}) => {
      const n = (i) => {
        const r = (a) => (typeof a == "string" ? i === a : a.test(i));
        return e ? e.some(r) : t ? !t.some(r) : !0;
      };
      for (const [i, r] of y(s.constructor.prototype)) {
        if (r === "constructor" || !n(r)) continue;
        const a = Reflect.getOwnPropertyDescriptor(i, r);
        a && typeof a.value == "function" && (s[r] = s[r].bind(s));
      }
      return s;
    },
    m = c(_),
    P = {
      name: "@jspsych/plugin-audio-keyboard-response",
      version: "2.0.0",
      description: "jsPsych plugin for playing an audio file and getting a keyboard response",
      type: "module",
      main: "dist/index.cjs",
      exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
      typings: "dist/index.d.ts",
      unpkg: "dist/index.browser.min.js",
      files: ["src", "dist"],
      source: "src/index.ts",
      scripts: {
        test: "jest",
        "test:watch": "npm test -- --watch",
        tsc: "tsc",
        build: "rollup --config",
        "build:watch": "npm run build -- --watch",
      },
      repository: {
        type: "git",
        url: "git+https://github.com/jspsych/jsPsych.git",
        directory: "packages/plugin-audio-keyboard-response",
      },
      author: "Josh de Leeuw",
      license: "MIT",
      bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
      homepage: "https://www.jspsych.org/latest/plugins/audio-keyboard-response",
      peerDependencies: { jspsych: ">=7.1.0" },
      devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
    },
    u = (s, e, t) =>
      new Promise((n, i) => {
        var r = (l) => {
            try {
              p(t.next(l));
            } catch (d) {
              i(d);
            }
          },
          a = (l) => {
            try {
              p(t.throw(l));
            } catch (d) {
              i(d);
            }
          },
          p = (l) => (l.done ? n(l.value) : Promise.resolve(l.value).then(r, a));
        p((t = t.apply(s, e)).next());
      });
  const g = {
    name: "audio-keyboard-response",
    version: P.version,
    parameters: {
      stimulus: { type: o.ParameterType.AUDIO, default: void 0 },
      choices: { type: o.ParameterType.KEYS, default: "ALL_KEYS" },
      prompt: { type: o.ParameterType.HTML_STRING, pretty_name: "Prompt", default: null },
      trial_duration: { type: o.ParameterType.INT, default: null },
      response_ends_trial: { type: o.ParameterType.BOOL, default: !0 },
      trial_ends_after_audio: {
        type: o.ParameterType.BOOL,
        pretty_name: "Trial ends after audio",
        default: !1,
      },
      response_allowed_while_playing: { type: o.ParameterType.BOOL, default: !0 },
    },
    data: {
      response: { type: o.ParameterType.STRING },
      rt: { type: o.ParameterType.INT },
      stimulus: { type: o.ParameterType.STRING },
    },
  };
  class h {
    constructor(e) {
      (this.jsPsych = e), (this.response = { rt: null, key: null }), m(this);
    }
    trial(e, t, n) {
      return new Promise((i) =>
        u(this, null, function* () {
          var r;
          (this.finish = i),
            (this.params = t),
            (this.display = e),
            (this.audio = yield this.jsPsych.pluginAPI.getAudioPlayer(t.stimulus)),
            t.trial_ends_after_audio && this.audio.addEventListener("ended", this.end_trial),
            t.prompt !== null && (e.innerHTML = t.prompt),
            (this.startTime =
              (r = this.jsPsych.pluginAPI.audioContext()) == null ? void 0 : r.currentTime),
            t.response_allowed_while_playing
              ? this.setup_keyboard_listener()
              : t.trial_ends_after_audio ||
                this.audio.addEventListener("ended", this.setup_keyboard_listener),
            t.trial_duration !== null &&
              this.jsPsych.pluginAPI.setTimeout(() => {
                this.end_trial();
              }, t.trial_duration),
            n(),
            this.audio.play();
        })
      );
    }
    end_trial() {
      this.jsPsych.pluginAPI.clearAllTimeouts(),
        this.audio.stop(),
        this.audio.removeEventListener("ended", this.end_trial),
        this.audio.removeEventListener("ended", this.setup_keyboard_listener),
        this.jsPsych.pluginAPI.cancelAllKeyboardResponses();
      var e = { rt: this.response.rt, response: this.response.key, stimulus: this.params.stimulus };
      (this.display.innerHTML = ""), this.finish(e);
    }
    after_response(e) {
      (this.response = e), this.params.response_ends_trial && this.end_trial();
    }
    setup_keyboard_listener() {
      this.jsPsych.pluginAPI.useWebaudio
        ? this.jsPsych.pluginAPI.getKeyboardResponse({
            callback_function: this.after_response,
            valid_responses: this.params.choices,
            rt_method: "audio",
            persist: !1,
            allow_held_key: !1,
            audio_context: this.jsPsych.pluginAPI.audioContext(),
            audio_context_start_time: this.startTime,
          })
        : this.jsPsych.pluginAPI.getKeyboardResponse({
            callback_function: this.after_response,
            valid_responses: this.params.choices,
            rt_method: "performance",
            persist: !1,
            allow_held_key: !1,
          });
    }
    simulate(e, t, n, i) {
      return u(this, null, function* () {
        if (t == "data-only") return i(), this.simulate_data_only(e, n);
        if (t == "visual") return this.simulate_visual(e, n, i);
      });
    }
    simulate_data_only(e, t) {
      return this.create_simulation_data(e, t);
    }
    simulate_visual(e, t, n) {
      return u(this, null, function* () {
        const i = this.create_simulation_data(e, t),
          r = this.jsPsych.getDisplayElement(),
          a = () => {
            i.rt !== null && this.jsPsych.pluginAPI.pressKey(i.response, i.rt);
          };
        return yield this.trial(r, e, () => {
          n(), e.response_allowed_while_playing ? a() : this.audio.addEventListener("ended", a);
        });
      });
    }
    create_simulation_data(e, t) {
      const n = {
          stimulus: e.stimulus,
          rt: this.jsPsych.randomization.sampleExGaussian(500, 50, 0.006666666666666667, !0),
          response: this.jsPsych.pluginAPI.getValidKey(e.choices),
        },
        i = this.jsPsych.pluginAPI.mergeSimulationData(n, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, i), i;
    }
  }
  return (h.info = g), h;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
