var jsPsychSameDifferentImage = (function (i) {
  "use strict";
  var y = {
    name: "@jspsych/plugin-same-different-image",
    version: "2.0.0",
    description:
      "jsPsych plugin for showing two stimuli sequentially and getting a same / different judgment",
    type: "module",
    main: "dist/index.cjs",
    exports: { import: "./dist/index.js", require: "./dist/index.cjs" },
    typings: "dist/index.d.ts",
    unpkg: "dist/index.browser.min.js",
    files: ["src", "dist"],
    source: "src/index.ts",
    scripts: {
      test: "jest",
      "test:watch": "npm test -- --watch",
      tsc: "tsc",
      build: "rollup --config",
      "build:watch": "npm run build -- --watch",
    },
    repository: {
      type: "git",
      url: "git+https://github.com/jspsych/jsPsych.git",
      directory: "packages/plugin-same-different-image",
    },
    author: "Josh de Leeuw",
    license: "MIT",
    bugs: { url: "https://github.com/jspsych/jsPsych/issues" },
    homepage: "https://www.jspsych.org/latest/plugins/same-different-image",
    peerDependencies: { jspsych: ">=7.1.0" },
    devDependencies: { "@jspsych/config": "^3.0.0", "@jspsych/test-utils": "^1.2.0" },
  };
  const c = {
    name: "same-different-image",
    version: y.version,
    parameters: {
      stimuli: { type: i.ParameterType.IMAGE, default: void 0, array: !0 },
      answer: { type: i.ParameterType.SELECT, options: ["same", "different"], default: void 0 },
      same_key: { type: i.ParameterType.KEY, default: "q" },
      different_key: { type: i.ParameterType.KEY, default: "p" },
      first_stim_duration: { type: i.ParameterType.INT, default: 1e3 },
      gap_duration: { type: i.ParameterType.INT, default: 500 },
      second_stim_duration: { type: i.ParameterType.INT, default: 1e3 },
      prompt: { type: i.ParameterType.HTML_STRING, default: null },
    },
    data: {
      stimulus: { type: i.ParameterType.STRING, array: !0 },
      response: { type: i.ParameterType.STRING },
      rt: { type: i.ParameterType.INT },
      correct: { type: i.ParameterType.BOOL },
      answer: { type: i.ParameterType.STRING },
    },
  };
  class p {
    constructor(e) {
      this.jsPsych = e;
    }
    trial(e, t) {
      const a = () => {
        (e.innerHTML = ""), this.jsPsych.pluginAPI.setTimeout(r, t.gap_duration);
      };
      e.innerHTML =
        '<img class="jspsych-same-different-stimulus" src="' + t.stimuli[0] + '"></img>';
      var s;
      if (t.first_stim_duration > 0) this.jsPsych.pluginAPI.setTimeout(a, t.first_stim_duration);
      else {
        const n = (u) => {
          (s = u), a();
        };
        this.jsPsych.pluginAPI.getKeyboardResponse({
          callback_function: n,
          valid_responses: "ALL_KEYS",
          rt_method: "performance",
          persist: !1,
          allow_held_key: !1,
        });
      }
      const r = () => {
        var n = '<img class="jspsych-same-different-stimulus" src="' + t.stimuli[1] + '"></img>';
        t.prompt !== null && (n += t.prompt),
          (e.innerHTML = n),
          t.second_stim_duration > 0 &&
            this.jsPsych.pluginAPI.setTimeout(() => {
              e.querySelector(".jspsych-same-different-stimulus").style.visibility = "hidden";
            }, t.second_stim_duration);
        const u = (m) => {
          var l = !1,
            d = t.same_key,
            h = t.different_key;
          this.jsPsych.pluginAPI.compareKeys(m.key, d) && t.answer == "same" && (l = !0),
            this.jsPsych.pluginAPI.compareKeys(m.key, h) && t.answer == "different" && (l = !0);
          var o = {
            rt: m.rt,
            answer: t.answer,
            correct: l,
            stimulus: [t.stimuli[0], t.stimuli[1]],
            response: m.key,
          };
          s && ((o.rt_stim1 = s.rt), (o.response_stim1 = s.key)), this.jsPsych.finishTrial(o);
        };
        this.jsPsych.pluginAPI.getKeyboardResponse({
          callback_function: u,
          valid_responses: [t.same_key, t.different_key],
          rt_method: "performance",
          persist: !1,
          allow_held_key: !1,
        });
      };
    }
    simulate(e, t, a, s) {
      t == "data-only" && (s(), this.simulate_data_only(e, a)),
        t == "visual" && this.simulate_visual(e, a, s);
    }
    create_simulation_data(e, t) {
      const a = this.jsPsych.pluginAPI.getValidKey([e.same_key, e.different_key]),
        s = {
          stimuli: e.stimuli,
          response: a,
          answer: e.answer,
          correct: e.answer == "same" ? a == e.same_key : a == e.different_key,
          rt: this.jsPsych.randomization.sampleExGaussian(500, 50, 1 / 150, !0),
        };
      e.first_stim_duration == null &&
        ((s.rt_stim1 = this.jsPsych.randomization.sampleExGaussian(
          500,
          50,
          0.006666666666666667,
          !0
        )),
        (s.response_stim1 = this.jsPsych.pluginAPI.getValidKey([e.same_key, e.different_key])));
      const r = this.jsPsych.pluginAPI.mergeSimulationData(s, t);
      return this.jsPsych.pluginAPI.ensureSimulationDataConsistency(e, r), r;
    }
    simulate_data_only(e, t) {
      const a = this.create_simulation_data(e, t);
      this.jsPsych.finishTrial(a);
    }
    simulate_visual(e, t, a) {
      const s = this.create_simulation_data(e, t),
        r = this.jsPsych.getDisplayElement();
      this.trial(r, e),
        a(),
        e.first_stim_duration == null &&
          this.jsPsych.pluginAPI.pressKey(s.response_stim1, s.rt_stim1),
        this.jsPsych.pluginAPI.pressKey(s.response, e.first_stim_duration + e.gap_duration + s.rt);
    }
  }
  return (p.info = c), p;
})(jsPsychModule);
//# sourceMappingURL=index.browser.min.js.map
